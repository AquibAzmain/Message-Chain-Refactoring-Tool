There are 360 Message Chains in project net4
Following are the Message Chains and their respective refactoring suggestion:

----------------------------------
1. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new HexDumpProxyInitializer(REMOTE_HOST, REMOTE_PORT)).childOption(ChannelOption.AUTO_READ, false).bind(LOCAL_PORT).sync().channel().closeFuture().sync(), degree= 10, category= HIGH, containerMethod= main(), containerClass= HexDumpProxy}
-----

public class HexDumpProxy{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelHandlerChildHandlerChildOptionBindSyncChannelCloseFutureSync();
	...
	}
...
}


----------------------------------
2. OurMessageChain{ headers.set(HttpHeaderNames.UPGRADE, WEBSOCKET).set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE).set(HttpHeaderNames.HOST, websocketHostValue(wsURL)).set(HttpHeaderNames.ORIGIN, websocketOriginValue(wsURL)).set(HttpHeaderNames.SEC_WEBSOCKET_KEY1, key1).set(HttpHeaderNames.SEC_WEBSOCKET_KEY2, key2), degree= 6, category= MEDIUM, containerMethod= newHandshakeRequest(), containerClass= WebSocketClientHandshaker00}
-----

public class WebSocketClientHandshaker00{
...
	protected FullHttpRequest newHandshakeRequest(){
	...
		... headers.setSetSetSetSetSet();
	...
	}
...
}

public class HttpHeaders{
...
	public HttpHeaders setSetSetSetSetSet(){
	...
		... set(HttpHeaderNames.UPGRADE, WEBSOCKET).setSetSetSetSet();
	...
	}
...
}

public class HttpHeaders{
...
	public HttpHeaders setSetSetSetSet(){
	...
		... set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE).setSetSetSet();
	...
	}
...
}

public class HttpHeaders{
...
	public HttpHeaders setSetSetSet(){
	...
		... set(HttpHeaderNames.HOST, websocketHostValue(wsURL)).setSetSet();
	...
	}
...
}

public class HttpHeaders{
...
	public HttpHeaders setSetSet(){
	...
		... set(HttpHeaderNames.ORIGIN, websocketOriginValue(wsURL)).setSet();
	...
	}
...
}

public class HttpHeaders{
...
	public HttpHeaders setSet(){
	...
		... set(HttpHeaderNames.SEC_WEBSOCKET_KEY1, key1).set();
	...
	}
...
}


----------------------------------
3. OurMessageChain{ headers.set(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET).set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE).set(HttpHeaderNames.SEC_WEBSOCKET_KEY, key).set(HttpHeaderNames.HOST, websocketHostValue(wsURL)).set(HttpHeaderNames.SEC_WEBSOCKET_ORIGIN, websocketOriginValue(wsURL)), degree= 5, category= MEDIUM, containerMethod= newHandshakeRequest(), containerClass= WebSocketClientHandshaker07}
-----

public class WebSocketClientHandshaker07{
...
	protected FullHttpRequest newHandshakeRequest(){
	...
		... headers.setSetSetSetSet();
	...
	}
...
}

public class HttpHeaders{
...
	public HttpHeaders setSetSetSetSet(){
	...
		... set(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET).setSetSetSet();
	...
	}
...
}

public class HttpHeaders{
...
	public HttpHeaders setSetSetSet(){
	...
		... set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE).setSetSet();
	...
	}
...
}

public class HttpHeaders{
...
	public HttpHeaders setSetSet(){
	...
		... set(HttpHeaderNames.SEC_WEBSOCKET_KEY, key).setSet();
	...
	}
...
}

public class HttpHeaders{
...
	public HttpHeaders setSet(){
	...
		... set(HttpHeaderNames.HOST, websocketHostValue(wsURL)).set();
	...
	}
...
}


----------------------------------
4. OurMessageChain{ headers.set(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET).set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE).set(HttpHeaderNames.SEC_WEBSOCKET_KEY, key).set(HttpHeaderNames.HOST, websocketHostValue(wsURL)).set(HttpHeaderNames.SEC_WEBSOCKET_ORIGIN, websocketOriginValue(wsURL)), degree= 5, category= MEDIUM, containerMethod= newHandshakeRequest(), containerClass= WebSocketClientHandshaker08}
-----

public class WebSocketClientHandshaker08{
...
	protected FullHttpRequest newHandshakeRequest(){
	...
		... headers.setSetSetSetSet();
	...
	}
...
}

public class HttpHeaders{
...
	public HttpHeaders setSetSetSetSet(){
	...
		... set(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET).setSetSetSet();
	...
	}
...
}

public class HttpHeaders{
...
	public HttpHeaders setSetSetSet(){
	...
		... set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE).setSetSet();
	...
	}
...
}

public class HttpHeaders{
...
	public HttpHeaders setSetSet(){
	...
		... set(HttpHeaderNames.SEC_WEBSOCKET_KEY, key).setSet();
	...
	}
...
}

public class HttpHeaders{
...
	public HttpHeaders setSet(){
	...
		... set(HttpHeaderNames.HOST, websocketHostValue(wsURL)).set();
	...
	}
...
}


----------------------------------
5. OurMessageChain{ headers.set(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET).set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE).set(HttpHeaderNames.SEC_WEBSOCKET_KEY, key).set(HttpHeaderNames.HOST, websocketHostValue(wsURL)).set(HttpHeaderNames.SEC_WEBSOCKET_ORIGIN, websocketOriginValue(wsURL)), degree= 5, category= MEDIUM, containerMethod= newHandshakeRequest(), containerClass= WebSocketClientHandshaker13}
-----

public class WebSocketClientHandshaker13{
...
	protected FullHttpRequest newHandshakeRequest(){
	...
		... headers.setSetSetSetSet();
	...
	}
...
}

public class HttpHeaders{
...
	public HttpHeaders setSetSetSetSet(){
	...
		... set(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET).setSetSetSet();
	...
	}
...
}

public class HttpHeaders{
...
	public HttpHeaders setSetSetSet(){
	...
		... set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE).setSetSet();
	...
	}
...
}

public class HttpHeaders{
...
	public HttpHeaders setSetSet(){
	...
		... set(HttpHeaderNames.SEC_WEBSOCKET_KEY, key).setSet();
	...
	}
...
}

public class HttpHeaders{
...
	public HttpHeaders setSet(){
	...
		... set(HttpHeaderNames.HOST, websocketHostValue(wsURL)).set();
	...
	}
...
}


----------------------------------
6. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).option(ChannelOption.SO_BACKLOG, 100).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new ChannelInitializer<SocketChannel>() {

    @Override
    public void initChannel(SocketChannel ch) throws Exception {
        ChannelPipeline p = ch.pipeline();
        if (sslCtx != null) {
            p.addLast(sslCtx.newHandler(ch.alloc()));
        }
        // p.addLast(new LoggingHandler(LogLevel.INFO));
        p.addLast(serverHandler);
    }
}), degree= 5, category= MEDIUM, containerMethod= main(), containerClass= EchoServer}
-----

public class EchoServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelOptionHandlerChildHandler();
	...
	}
...
}


----------------------------------
7. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).option(ChannelOption.SO_BACKLOG, 100).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new ChannelInitializer<SocketChannel>() {

    @Override
    public void initChannel(SocketChannel ch) throws Exception {
        ChannelPipeline p = ch.pipeline();
        if (sslCtx != null) {
            p.addLast(sslCtx.newHandler(ch.alloc()));
        }
        p.addLast(new StringEncoder(CharsetUtil.UTF_8), new LineBasedFrameDecoder(8192), new StringDecoder(CharsetUtil.UTF_8), new ChunkedWriteHandler(), new FileServerHandler());
    }
}), degree= 5, category= MEDIUM, containerMethod= main(), containerClass= FileServer}
-----

public class FileServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelOptionHandlerChildHandler();
	...
	}
...
}


----------------------------------
8. OurMessageChain{ b.connect(HOST, PORT).sync().channel().closeFuture().sync(), degree= 5, category= MEDIUM, containerMethod= main(), containerClass= ObjectEchoClient}
-----

public class ObjectEchoClient{
...
	public static void main(String[] args) throws Exception{
	...
		... b.connectSyncChannelCloseFutureSync();
	...
	}
...
}

public class Bootstrap{
...
	public ChannelFuture connectSyncChannelCloseFutureSync(){
	...
		... connect(HOST, PORT).syncChannelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture syncChannelCloseFutureSync(){
	...
		... sync().channelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture channelCloseFutureSync(){
	...
		... channel().closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
9. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioSctpServerChannel.class).option(ChannelOption.SO_BACKLOG, 100).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new ChannelInitializer<SctpChannel>() {

    @Override
    public void initChannel(SctpChannel ch) throws Exception {
        ch.pipeline().addLast(// new LoggingHandler(LogLevel.INFO),
        new SctpEchoServerHandler());
    }
}), degree= 5, category= MEDIUM, containerMethod= main(), containerClass= SctpMultiHomingEchoServer}
-----

public class SctpMultiHomingEchoServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelOptionHandlerChildHandler();
	...
	}
...
}


----------------------------------
10. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioSctpServerChannel.class).option(ChannelOption.SO_BACKLOG, 100).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new ChannelInitializer<SctpChannel>() {

    @Override
    public void initChannel(SctpChannel ch) throws Exception {
        ch.pipeline().addLast(// new LoggingHandler(LogLevel.INFO),
        serverHandler);
    }
}), degree= 5, category= MEDIUM, containerMethod= main(), containerClass= SctpEchoServer}
-----

public class SctpEchoServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelOptionHandlerChildHandler();
	...
	}
...
}


----------------------------------
11. OurMessageChain{ b.connect(HOST, PORT).sync().channel().closeFuture().sync(), degree= 5, category= MEDIUM, containerMethod= main(), containerClass= StompClient}
-----

public class StompClient{
...
	public static void main(String[] args) throws Exception{
	...
		... b.connectSyncChannelCloseFutureSync();
	...
	}
...
}

public class Bootstrap{
...
	public ChannelFuture connectSyncChannelCloseFutureSync(){
	...
		... connect(HOST, PORT).syncChannelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture syncChannelCloseFutureSync(){
	...
		... sync().channelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture channelCloseFutureSync(){
	...
		... channel().closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
12. OurMessageChain{ boot.group(acceptGroup, connectGroup).channelFactory(NioUdtProvider.BYTE_ACCEPTOR).option(ChannelOption.SO_BACKLOG, 10).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new ChannelInitializer<UdtChannel>() {

    @Override
    public void initChannel(final UdtChannel ch) throws Exception {
        ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO), new ByteEchoServerHandler());
    }
}), degree= 5, category= MEDIUM, containerMethod= main(), containerClass= ByteEchoServer}
-----

public class ByteEchoServer{
...
	public static void main(String[] args) throws Exception{
	...
		... boot.groupChannelFactoryOptionHandlerChildHandler();
	...
	}
...
}


----------------------------------
13. OurMessageChain{ boot.group(acceptGroup, connectGroup).channelFactory(NioUdtProvider.MESSAGE_ACCEPTOR).option(ChannelOption.SO_BACKLOG, 10).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new ChannelInitializer<UdtChannel>() {

    @Override
    public void initChannel(final UdtChannel ch) throws Exception {
        ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO), new MsgEchoServerHandler());
    }
}), degree= 5, category= MEDIUM, containerMethod= main(), containerClass= MsgEchoServer}
-----

public class MsgEchoServer{
...
	public static void main(String[] args) throws Exception{
	...
		... boot.groupChannelFactoryOptionHandlerChildHandler();
	...
	}
...
}


----------------------------------
14. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new ChannelInitializer<SocketChannel>() {

    @Override
    public void initChannel(SocketChannel ch) {
        ChannelPipeline p = ch.pipeline();
        if (sslCtx != null) {
            p.addLast(sslCtx.newHandler(ch.alloc()));
        }
        p.addLast(new DiscardServerHandler());
    }
}), degree= 4, category= MEDIUM, containerMethod= main(), containerClass= DiscardServer}
-----

public class DiscardServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
15. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new FactorialServerInitializer(sslCtx)), degree= 4, category= MEDIUM, containerMethod= main(), containerClass= FactorialServer}
-----

public class FactorialServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
16. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new HttpCorsServerInitializer(sslCtx)), degree= 4, category= MEDIUM, containerMethod= main(), containerClass= HttpCorsServer}
-----

public class HttpCorsServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
17. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new HttpStaticFileServerInitializer(sslCtx)), degree= 4, category= MEDIUM, containerMethod= main(), containerClass= HttpStaticFileServer}
-----

public class HttpStaticFileServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
18. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new HttpHelloWorldServerInitializer(sslCtx)), degree= 4, category= MEDIUM, containerMethod= main(), containerClass= HttpHelloWorldServer}
-----

public class HttpHelloWorldServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
19. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new HttpSnoopServerInitializer(sslCtx)), degree= 4, category= MEDIUM, containerMethod= main(), containerClass= HttpSnoopServer}
-----

public class HttpSnoopServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
20. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new WebSocketServerInitializer(sslCtx)), degree= 4, category= MEDIUM, containerMethod= main(), containerClass= WebSocketServer}
-----

public class WebSocketServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
21. OurMessageChain{ b.group(group).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new Http2ServerInitializer(sslCtx)), degree= 4, category= MEDIUM, containerMethod= main(), containerClass= Http2Server}
-----

public class Http2Server{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
22. OurMessageChain{ b.group(group).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new Http2ServerInitializer(sslCtx)), degree= 4, category= MEDIUM, containerMethod= main(), containerClass= Http2Server}
-----

public class Http2Server{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
23. OurMessageChain{ b.group(group).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new Http2ServerInitializer(sslCtx)), degree= 4, category= MEDIUM, containerMethod= main(), containerClass= Http2Server}
-----

public class Http2Server{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
24. OurMessageChain{ b.group(group).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new ChannelInitializer<SocketChannel>() {

    @Override
    protected void initChannel(SocketChannel ch) throws Exception {
        ch.pipeline().addLast(new HttpRequestDecoder(), new HttpResponseEncoder(), new HttpObjectAggregator(MAX_CONTENT_LENGTH), new Http1RequestHandler());
    }
}), degree= 4, category= MEDIUM, containerMethod= start(), containerClass= HttpServer}
-----

public class HttpServer{
...
	public ChannelFuture start() throws Exception{
	...
		... b.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
25. OurMessageChain{ sb.group(serverGroup).channel(LocalServerChannel.class).handler(new ChannelInitializer<LocalServerChannel>() {

    @Override
    public void initChannel(LocalServerChannel ch) throws Exception {
        ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO));
    }
}).childHandler(new ChannelInitializer<LocalChannel>() {

    @Override
    public void initChannel(LocalChannel ch) throws Exception {
        ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO), new LocalEchoServerHandler());
    }
}), degree= 4, category= MEDIUM, containerMethod= main(), containerClass= LocalEcho}
-----

public class LocalEcho{
...
	public static void main(String[] args) throws Exception{
	...
		... sb.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
26. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new ChannelInitializer<SocketChannel>() {

    @Override
    public void initChannel(SocketChannel ch) throws Exception {
        ChannelPipeline p = ch.pipeline();
        if (sslCtx != null) {
            p.addLast(sslCtx.newHandler(ch.alloc()));
        }
        p.addLast(new ObjectEncoder(), new ObjectDecoder(ClassResolvers.cacheDisabled(null)), new ObjectEchoServerHandler());
    }
}), degree= 4, category= MEDIUM, containerMethod= main(), containerClass= ObjectEchoServer}
-----

public class ObjectEchoServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
27. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new ChannelInitializer<SocketChannel>() {

    @Override
    public void initChannel(SocketChannel ch) throws Exception {
        ch.pipeline().addLast(new PortUnificationServerHandler(sslCtx));
    }
}), degree= 4, category= MEDIUM, containerMethod= main(), containerClass= PortUnificationServer}
-----

public class PortUnificationServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
28. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new SecureChatServerInitializer(sslCtx)), degree= 4, category= MEDIUM, containerMethod= main(), containerClass= SecureChatServer}
-----

public class SecureChatServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
29. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new SocksServerInitializer()), degree= 4, category= MEDIUM, containerMethod= main(), containerClass= SocksServer}
-----

public class SocksServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
30. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new SpdyServerInitializer(sslCtx)), degree= 4, category= MEDIUM, containerMethod= main(), containerClass= SpdyServer}
-----

public class SpdyServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
31. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new TelnetServerInitializer(sslCtx)), degree= 4, category= MEDIUM, containerMethod= main(), containerClass= TelnetServer}
-----

public class TelnetServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
32. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new ChannelInitializer<SocketChannel>() {

    @Override
    public void initChannel(SocketChannel ch) {
        ch.pipeline().addLast(handler);
    }
}), degree= 4, category= MEDIUM, containerMethod= main(), containerClass= UptimeServer}
-----

public class UptimeServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
33. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new WorldClockServerInitializer(sslCtx)), degree= 4, category= MEDIUM, containerMethod= main(), containerClass= WorldClockServer}
-----

public class WorldClockServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelHandlerChildHandler();
	...
	}
...
}


----------------------------------
34. OurMessageChain{ buf.writeByte('0').writeByte(CR).writeByte(LF).resetWriterIndex(), degree= 4, category= MEDIUM, containerMethod= chainedBytes3(), containerClass= WriteBytesVsShortOrMediumBenchmark}
-----

public class WriteBytesVsShortOrMediumBenchmark{
...
	public ByteBuf chainedBytes3(){
	...
		... buf.writeByteWriteByteWriteByteResetWriterIndex();
	...
	}
...
}

public class ByteBuf{
...
	public ByteBuf writeByteWriteByteWriteByteResetWriterIndex(){
	...
		... writeByte('0').writeByteWriteByteResetWriterIndex();
	...
	}
...
}

public class ByteBuf{
...
	public ByteBuf writeByteWriteByteResetWriterIndex(){
	...
		... writeByte(CR).writeByteResetWriterIndex();
	...
	}
...
}

public class ByteBuf{
...
	public ByteBuf writeByteResetWriterIndex(){
	...
		... writeByte(LF).resetWriterIndex();
	...
	}
...
}


----------------------------------
35. OurMessageChain{ dnsResolverBuilder.eventLoop(eventLoop).channelFactory(channelFactory).nameServerProvider(nameServerProvider).build(), degree= 4, category= MEDIUM, containerMethod= newNameResolver(), containerClass= DnsAddressResolverGroup}
-----

public class DnsAddressResolverGroup{
...
	protected NameResolver<InetAddress> newNameResolver(EventLoop eventLoop, ChannelFactory<? extends DatagramChannel> channelFactory, DnsServerAddressStreamProvider nameServerProvider) throws Exception{
	...
		... dnsResolverBuilder.eventLoopChannelFactoryNameServerProviderBuild();
	...
	}
...
}

public class DnsNameResolverBuilder{
...
	public .1 eventLoopChannelFactoryNameServerProviderBuild(){
	...
		... eventLoop(eventLoop).channelFactoryNameServerProviderBuild();
	...
	}
...
}


----------------------------------
36. OurMessageChain{ ctx.channel().config().isAutoRead(), degree= 3, category= LOW, containerMethod= channelReadComplete(), containerClass= MessageAggregator}
-----

public class MessageAggregator{
...
	public void channelReadComplete(ChannelHandlerContext ctx) throws Exception{
	...
		... ctx.channelConfigIsAutoRead();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelConfigIsAutoRead(){
	...
		... channel().configIsAutoRead();
	...
	}
...
}

public class Channel{
...
	public boolean configIsAutoRead(){
	...
		... config().isAutoRead();
	...
	}
...
}


----------------------------------
37. OurMessageChain{ ctx.channel().metadata().hasDisconnect(), degree= 3, category= LOW, containerMethod= beginEncode(), containerClass= HttpContentCompressor}
-----

public class HttpContentCompressor{
...
	protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception{
	...
		... ctx.channelMetadataHasDisconnect();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelMetadataHasDisconnect(){
	...
		... channel().metadataHasDisconnect();
	...
	}
...
}

public class Channel{
...
	public boolean metadataHasDisconnect(){
	...
		... metadata().hasDisconnect();
	...
	}
...
}


----------------------------------
38. OurMessageChain{ httpResponse.status().codeClass().equals(HttpStatusClass.CLIENT_ERROR), degree= 3, category= LOW, containerMethod= ignoreContentAfterContinueResponse(), containerClass= HttpObjectAggregator}
-----

public class HttpObjectAggregator{
...
	protected boolean ignoreContentAfterContinueResponse(Object msg){
	...
		... httpResponse.statusCodeClassEquals();
	...
	}
...
}

public class HttpResponse{
...
	public void statusCodeClassEquals(){
	...
		... status().codeClassEquals();
	...
	}
...
}

public class HttpResponseStatus{
...
	public void codeClassEquals(){
	...
		... codeClass().equals();
	...
	}
...
}


----------------------------------
39. OurMessageChain{ ctx.channel().closeFuture().addListener(new ChannelFutureListener() {

    @Override
    public void operationComplete(ChannelFuture future) throws Exception {
        spdyHeaderBlockDecoder.end();
        spdyHeaderBlockEncoder.end();
    }
}), degree= 3, category= LOW, containerMethod= handlerAdded(), containerClass= SpdyFrameCodec}
-----

public class SpdyFrameCodec{
...
	public void handlerAdded(ChannelHandlerContext ctx) throws Exception{
	...
		... ctx.channelCloseFutureAddListener();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public ChannelFuture channelCloseFutureAddListener(){
	...
		... channel().closeFutureAddListener();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureAddListener(){
	...
		... closeFuture().addListener();
	...
	}
...
}


----------------------------------
40. OurMessageChain{ ctx.channel().config().isAutoRead(), degree= 3, category= LOW, containerMethod= channelReadComplete(), containerClass= SpdyFrameCodec}
-----

public class SpdyFrameCodec{
...
	public void channelReadComplete(ChannelHandlerContext ctx) throws Exception{
	...
		... ctx.channelConfigIsAutoRead();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelConfigIsAutoRead(){
	...
		... channel().configIsAutoRead();
	...
	}
...
}

public class Channel{
...
	public boolean configIsAutoRead(){
	...
		... config().isAutoRead();
	...
	}
...
}


----------------------------------
41. OurMessageChain{ encoder.connection().remote().createStream(streamId, true), degree= 3, category= LOW, containerMethod= onStreamError(), containerClass= Http2ConnectionHandler}
-----

public class Http2ConnectionHandler{
...
	protected void onStreamError(ChannelHandlerContext ctx, boolean outbound, @SuppressWarnings("unused") Throwable cause, StreamException http2Ex){
	...
		... encoder.connectionRemoteCreateStream();
	...
	}
...
}

public class Http2ConnectionEncoder{
...
	public void connectionRemoteCreateStream(){
	...
		... connection().remoteCreateStream();
	...
	}
...
}

public class Http2Connection{
...
	public void remoteCreateStream(){
	...
		... remote().createStream();
	...
	}
...
}


----------------------------------
42. OurMessageChain{ ctx.channel().eventLoop().register(ch), degree= 3, category= LOW, containerMethod= onHttp2UpgradeStreamInitialized(), containerClass= Http2MultiplexCodec}
-----

public class Http2MultiplexCodec{
...
	private void onHttp2UpgradeStreamInitialized(ChannelHandlerContext ctx, Http2MultiplexCodecStream stream){
	...
		... ctx.channelEventLoopRegister();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void channelEventLoopRegister(){
	...
		... channel().eventLoopRegister();
	...
	}
...
}

public class Channel{
...
	public void eventLoopRegister(){
	...
		... eventLoop().register();
	...
	}
...
}


----------------------------------
43. OurMessageChain{ ctx.channel().eventLoop().register(new DefaultHttp2StreamChannel(s, false)), degree= 3, category= LOW, containerMethod= onHttp2StreamStateChanged(), containerClass= Http2MultiplexCodec}
-----

public class Http2MultiplexCodec{
...
	final void onHttp2StreamStateChanged(ChannelHandlerContext ctx, Http2FrameStream stream){
	...
		... ctx.channelEventLoopRegister();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void channelEventLoopRegister(){
	...
		... channel().eventLoopRegister();
	...
	}
...
}

public class Channel{
...
	public void eventLoopRegister(){
	...
		... eventLoop().register();
	...
	}
...
}


----------------------------------
44. OurMessageChain{ f.channel().closeFuture().sync(), degree= 3, category= LOW, containerMethod= main(), containerClass= DiscardClient}
-----

public class DiscardClient{
...
	public static void main(String[] args) throws Exception{
	...
		... f.channelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture channelCloseFutureSync(){
	...
		... channel().closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
45. OurMessageChain{ ctx.alloc().directBuffer(DiscardClient.SIZE).writeZero(DiscardClient.SIZE), degree= 3, category= LOW, containerMethod= channelActive(), containerClass= DiscardClientHandler}
-----

public class DiscardClientHandler{
...
	public void channelActive(ChannelHandlerContext ctx){
	...
		... ctx.allocDirectBufferWriteZero();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public ByteBuf allocDirectBufferWriteZero(){
	...
		... alloc().directBufferWriteZero();
	...
	}
...
}

public class ByteBufAllocator{
...
	public ByteBuf directBufferWriteZero(){
	...
		... directBuffer(DiscardClient.SIZE).writeZero();
	...
	}
...
}


----------------------------------
46. OurMessageChain{ f.channel().closeFuture().sync(), degree= 3, category= LOW, containerMethod= main(), containerClass= DiscardServer}
-----

public class DiscardServer{
...
	public static void main(String[] args) throws Exception{
	...
		... f.channelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture channelCloseFutureSync(){
	...
		... channel().closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
47. OurMessageChain{ f.channel().closeFuture().sync(), degree= 3, category= LOW, containerMethod= main(), containerClass= EchoClient}
-----

public class EchoClient{
...
	public static void main(String[] args) throws Exception{
	...
		... f.channelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture channelCloseFutureSync(){
	...
		... channel().closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
48. OurMessageChain{ f.channel().closeFuture().sync(), degree= 3, category= LOW, containerMethod= main(), containerClass= EchoServer}
-----

public class EchoServer{
...
	public static void main(String[] args) throws Exception{
	...
		... f.channelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture channelCloseFutureSync(){
	...
		... channel().closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
49. OurMessageChain{ f.channel().pipeline().last(), degree= 3, category= LOW, containerMethod= main(), containerClass= FactorialClient}
-----

public class FactorialClient{
...
	public static void main(String[] args) throws Exception{
	...
		... f.channelPipelineLast();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelHandler channelPipelineLast(){
	...
		... channel().pipelineLast();
	...
	}
...
}

public class Channel{
...
	public ChannelHandler pipelineLast(){
	...
		... pipeline().last();
	...
	}
...
}


----------------------------------
50. OurMessageChain{ ctx.channel().close().addListener(new ChannelFutureListener() {

    @Override
    public void operationComplete(ChannelFuture future) {
        boolean offered = answer.offer(msg);
        assert offered;
    }
}), degree= 3, category= LOW, containerMethod= channelRead0(), containerClass= FactorialClientHandler}
-----

public class FactorialClientHandler{
...
	public void channelRead0(ChannelHandlerContext ctx, final BigInteger msg){
	...
		... ctx.channelCloseAddListener();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void channelCloseAddListener(){
	...
		... channel().closeAddListener();
	...
	}
...
}

public class Channel{
...
	public void closeAddListener(){
	...
		... close().addListener();
	...
	}
...
}


----------------------------------
51. OurMessageChain{ f.channel().closeFuture().sync(), degree= 3, category= LOW, containerMethod= main(), containerClass= FileServer}
-----

public class FileServer{
...
	public static void main(String[] args) throws Exception{
	...
		... f.channelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture channelCloseFutureSync(){
	...
		... channel().closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
52. OurMessageChain{ b.connect(host, port).sync().channel(), degree= 3, category= LOW, containerMethod= main(), containerClass= HttpSnoopClient}
-----

public class HttpSnoopClient{
...
	public static void main(String[] args) throws Exception{
	...
		... b.connectSyncChannel();
	...
	}
...
}

public class Bootstrap{
...
	public Channel connectSyncChannel(){
	...
		... connect(host, port).syncChannel();
	...
	}
...
}

public class ChannelFuture{
...
	public Channel syncChannel(){
	...
		... sync().channel();
	...
	}
...
}


----------------------------------
53. OurMessageChain{ b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).childHandler(new WebSocketServerInitializer(sslCtx)), degree= 3, category= LOW, containerMethod= main(), containerClass= WebSocketServer}
-----

public class WebSocketServer{
...
	public static void main(String[] args) throws Exception{
	...
		... b.groupChannelChildHandler();
	...
	}
...
}


----------------------------------
54. OurMessageChain{ b.connect(uri.getHost(), port).sync().channel(), degree= 3, category= LOW, containerMethod= main(), containerClass= WebSocketClient}
-----

public class WebSocketClient{
...
	public static void main(String[] args) throws Exception{
	...
		... b.connectSyncChannel();
	...
	}
...
}

public class Bootstrap{
...
	public Channel connectSyncChannel(){
	...
		... connect(uri.getHost(), port).syncChannel();
	...
	}
...
}

public class ChannelFuture{
...
	public Channel syncChannel(){
	...
		... sync().channel();
	...
	}
...
}


----------------------------------
55. OurMessageChain{ b.connect().syncUninterruptibly().channel(), degree= 3, category= LOW, containerMethod= main(), containerClass= Http2Client}
-----

public class Http2Client{
...
	public static void main(String[] args) throws Exception{
	...
		... b.connectSyncUninterruptiblyChannel();
	...
	}
...
}

public class Bootstrap{
...
	public Channel connectSyncUninterruptiblyChannel(){
	...
		... connect().syncUninterruptiblyChannel();
	...
	}
...
}

public class ChannelFuture{
...
	public Channel syncUninterruptiblyChannel(){
	...
		... syncUninterruptibly().channel();
	...
	}
...
}


----------------------------------
56. OurMessageChain{ b.group(group).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>() {

    @Override
    protected void initChannel(SocketChannel ch) throws Exception {
        ch.pipeline().addLast(sslCtx.newHandler(ch.alloc()), new Http2OrHttpHandler());
    }
}), degree= 3, category= LOW, containerMethod= start(), containerClass= Http2Server}
-----

public class Http2Server{
...
	public ChannelFuture start() throws Exception{
	...
		... b.groupChannelChildHandler();
	...
	}
...
}


----------------------------------
57. OurMessageChain{ cb.connect(addr).sync().channel(), degree= 3, category= LOW, containerMethod= main(), containerClass= LocalEcho}
-----

public class LocalEcho{
...
	public static void main(String[] args) throws Exception{
	...
		... cb.connectSyncChannel();
	...
	}
...
}

public class Bootstrap{
...
	public Channel connectSyncChannel(){
	...
		... connect(addr).syncChannel();
	...
	}
...
}

public class ChannelFuture{
...
	public Channel syncChannel(){
	...
		... sync().channel();
	...
	}
...
}


----------------------------------
58. OurMessageChain{ b.connect(HOST, PORT).sync().channel(), degree= 3, category= LOW, containerMethod= main(), containerClass= MemcacheClient}
-----

public class MemcacheClient{
...
	public static void main(String[] args) throws Exception{
	...
		... b.connectSyncChannel();
	...
	}
...
}

public class Bootstrap{
...
	public Channel connectSyncChannel(){
	...
		... connect(HOST, PORT).syncChannel();
	...
	}
...
}

public class ChannelFuture{
...
	public Channel syncChannel(){
	...
		... sync().channel();
	...
	}
...
}


----------------------------------
59. OurMessageChain{ bootstrap.connect(host, 443).syncUninterruptibly().channel(), degree= 3, category= LOW, containerMethod= main(), containerClass= OcspClientExample}
-----

public class OcspClientExample{
...
	public static void main(String[] args) throws Exception{
	...
		... bootstrap.connectSyncUninterruptiblyChannel();
	...
	}
...
}

public class Bootstrap{
...
	public Channel connectSyncUninterruptiblyChannel(){
	...
		... connect(host, 443).syncUninterruptiblyChannel();
	...
	}
...
}

public class ChannelFuture{
...
	public Channel syncUninterruptiblyChannel(){
	...
		... syncUninterruptibly().channel();
	...
	}
...
}


----------------------------------
60. OurMessageChain{ b.connect(HOST, PORT).sync().channel(), degree= 3, category= LOW, containerMethod= main(), containerClass= RedisClient}
-----

public class RedisClient{
...
	public static void main(String[] args) throws Exception{
	...
		... b.connectSyncChannel();
	...
	}
...
}

public class Bootstrap{
...
	public Channel connectSyncChannel(){
	...
		... connect(HOST, PORT).syncChannel();
	...
	}
...
}

public class ChannelFuture{
...
	public Channel syncChannel(){
	...
		... sync().channel();
	...
	}
...
}


----------------------------------
61. OurMessageChain{ f.channel().closeFuture().sync(), degree= 3, category= LOW, containerMethod= main(), containerClass= RxtxClient}
-----

public class RxtxClient{
...
	public static void main(String[] args) throws Exception{
	...
		... f.channelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture channelCloseFutureSync(){
	...
		... channel().closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
62. OurMessageChain{ connectFuture.channel().closeFuture().sync(), degree= 3, category= LOW, containerMethod= main(), containerClass= SctpMultiHomingEchoClient}
-----

public class SctpMultiHomingEchoClient{
...
	public static void main(String[] args) throws Exception{
	...
		... connectFuture.channelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture channelCloseFutureSync(){
	...
		... channel().closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
63. OurMessageChain{ connectFuture.channel().closeFuture().sync(), degree= 3, category= LOW, containerMethod= main(), containerClass= SctpMultiHomingEchoServer}
-----

public class SctpMultiHomingEchoServer{
...
	public static void main(String[] args) throws Exception{
	...
		... connectFuture.channelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture channelCloseFutureSync(){
	...
		... channel().closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
64. OurMessageChain{ f.channel().closeFuture().sync(), degree= 3, category= LOW, containerMethod= main(), containerClass= SctpEchoClient}
-----

public class SctpEchoClient{
...
	public static void main(String[] args) throws Exception{
	...
		... f.channelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture channelCloseFutureSync(){
	...
		... channel().closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
65. OurMessageChain{ f.channel().closeFuture().sync(), degree= 3, category= LOW, containerMethod= main(), containerClass= SctpEchoServer}
-----

public class SctpEchoServer{
...
	public static void main(String[] args) throws Exception{
	...
		... f.channelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture channelCloseFutureSync(){
	...
		... channel().closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
66. OurMessageChain{ b.connect(HOST, PORT).sync().channel(), degree= 3, category= LOW, containerMethod= main(), containerClass= SecureChatClient}
-----

public class SecureChatClient{
...
	public static void main(String[] args) throws Exception{
	...
		... b.connectSyncChannel();
	...
	}
...
}

public class Bootstrap{
...
	public Channel connectSyncChannel(){
	...
		... connect(HOST, PORT).syncChannel();
	...
	}
...
}

public class ChannelFuture{
...
	public Channel syncChannel(){
	...
		... sync().channel();
	...
	}
...
}


----------------------------------
67. OurMessageChain{ b.connect().syncUninterruptibly().channel(), degree= 3, category= LOW, containerMethod= main(), containerClass= SpdyClient}
-----

public class SpdyClient{
...
	public static void main(String[] args) throws Exception{
	...
		... b.connectSyncUninterruptiblyChannel();
	...
	}
...
}

public class Bootstrap{
...
	public Channel connectSyncUninterruptiblyChannel(){
	...
		... connect().syncUninterruptiblyChannel();
	...
	}
...
}

public class ChannelFuture{
...
	public Channel syncUninterruptiblyChannel(){
	...
		... syncUninterruptibly().channel();
	...
	}
...
}


----------------------------------
68. OurMessageChain{ httpResponseHandler.queue().take().sync(), degree= 3, category= LOW, containerMethod= main(), containerClass= SpdyClient}
-----

public class SpdyClient{
...
	public static void main(String[] args) throws Exception{
	...
		... httpResponseHandler.queueTakeSync();
	...
	}
...
}


----------------------------------
69. OurMessageChain{ b.connect(HOST, PORT).sync().channel(), degree= 3, category= LOW, containerMethod= main(), containerClass= TelnetClient}
-----

public class TelnetClient{
...
	public static void main(String[] args) throws Exception{
	...
		... b.connectSyncChannel();
	...
	}
...
}

public class Bootstrap{
...
	public Channel connectSyncChannel(){
	...
		... connect(HOST, PORT).syncChannel();
	...
	}
...
}

public class ChannelFuture{
...
	public Channel syncChannel(){
	...
		... sync().channel();
	...
	}
...
}


----------------------------------
70. OurMessageChain{ f.channel().closeFuture().sync(), degree= 3, category= LOW, containerMethod= main(), containerClass= ByteEchoClient}
-----

public class ByteEchoClient{
...
	public static void main(String[] args) throws Exception{
	...
		... f.channelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture channelCloseFutureSync(){
	...
		... channel().closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
71. OurMessageChain{ future.channel().closeFuture().sync(), degree= 3, category= LOW, containerMethod= main(), containerClass= ByteEchoServer}
-----

public class ByteEchoServer{
...
	public static void main(String[] args) throws Exception{
	...
		... future.channelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture channelCloseFutureSync(){
	...
		... channel().closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
72. OurMessageChain{ f.channel().closeFuture().sync(), degree= 3, category= LOW, containerMethod= main(), containerClass= MsgEchoClient}
-----

public class MsgEchoClient{
...
	public static void main(String[] args) throws Exception{
	...
		... f.channelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture channelCloseFutureSync(){
	...
		... channel().closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
73. OurMessageChain{ future.channel().closeFuture().sync(), degree= 3, category= LOW, containerMethod= main(), containerClass= MsgEchoServer}
-----

public class MsgEchoServer{
...
	public static void main(String[] args) throws Exception{
	...
		... future.channelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture channelCloseFutureSync(){
	...
		... channel().closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
74. OurMessageChain{ f.channel().closeFuture().sync(), degree= 3, category= LOW, containerMethod= run(), containerClass= MsgEchoPeerBase}
-----

public class MsgEchoPeerBase{
...
	public void run() throws Exception{
	...
		... f.channelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture channelCloseFutureSync(){
	...
		... channel().closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
75. OurMessageChain{ future.channel().closeFuture().sync(), degree= 3, category= LOW, containerMethod= run(), containerClass= ByteEchoPeerBase}
-----

public class ByteEchoPeerBase{
...
	public void run() throws Exception{
	...
		... future.channelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture channelCloseFutureSync(){
	...
		... channel().closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
76. OurMessageChain{ f.channel().closeFuture().sync(), degree= 3, category= LOW, containerMethod= main(), containerClass= UptimeServer}
-----

public class UptimeServer{
...
	public static void main(String[] args) throws Exception{
	...
		... f.channelCloseFutureSync();
	...
	}
...
}

public class ChannelFuture{
...
	public ChannelFuture channelCloseFutureSync(){
	...
		... channel().closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
77. OurMessageChain{ b.connect(HOST, PORT).sync().channel(), degree= 3, category= LOW, containerMethod= main(), containerClass= WorldClockClient}
-----

public class WorldClockClient{
...
	public static void main(String[] args) throws Exception{
	...
		... b.connectSyncChannel();
	...
	}
...
}

public class Bootstrap{
...
	public Channel connectSyncChannel(){
	...
		... connect(HOST, PORT).syncChannel();
	...
	}
...
}

public class ChannelFuture{
...
	public Channel syncChannel(){
	...
		... sync().channel();
	...
	}
...
}


----------------------------------
78. OurMessageChain{ ctx.channel().eventLoop().submit(flushTask), degree= 3, category= LOW, containerMethod= scheduleFlush(), containerClass= FlushConsolidationHandler}
-----

public class FlushConsolidationHandler{
...
	private void scheduleFlush(final ChannelHandlerContext ctx){
	...
		... ctx.channelEventLoopSubmit();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void channelEventLoopSubmit(){
	...
		... channel().eventLoopSubmit();
	...
	}
...
}

public class Channel{
...
	public void eventLoopSubmit(){
	...
		... eventLoop().submit();
	...
	}
...
}


----------------------------------
79. OurMessageChain{ ctx.channel().config().isAutoRead(), degree= 3, category= LOW, containerMethod= readIfNeeded(), containerClass= SslHandler}
-----

public class SslHandler{
...
	private void readIfNeeded(ChannelHandlerContext ctx){
	...
		... ctx.channelConfigIsAutoRead();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelConfigIsAutoRead(){
	...
		... channel().configIsAutoRead();
	...
	}
...
}

public class Channel{
...
	public boolean configIsAutoRead(){
	...
		... config().isAutoRead();
	...
	}
...
}


----------------------------------
80. OurMessageChain{ ctx.channel().config().isAutoRead(), degree= 3, category= LOW, containerMethod= setHandshakeSuccess(), containerClass= SslHandler}
-----

public class SslHandler{
...
	private void setHandshakeSuccess(){
	...
		... ctx.channelConfigIsAutoRead();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelConfigIsAutoRead(){
	...
		... channel().configIsAutoRead();
	...
	}
...
}

public class Channel{
...
	public boolean configIsAutoRead(){
	...
		... config().isAutoRead();
	...
	}
...
}


----------------------------------
81. OurMessageChain{ ctx.channel().attr(READ_SUSPENDED).get(), degree= 3, category= LOW, containerMethod= isHandlerActive(), containerClass= AbstractTrafficShapingHandler}
-----

public class AbstractTrafficShapingHandler{
...
	protected static boolean isHandlerActive(ChannelHandlerContext ctx){
	...
		... ctx.channelAttr();
	...
	}
...
}


----------------------------------
82. OurMessageChain{ ctx.channel().unsafe().outboundBuffer(), degree= 3, category= LOW, containerMethod= setUserDefinedWritability(), containerClass= AbstractTrafficShapingHandler}
-----

public class AbstractTrafficShapingHandler{
...
	void setUserDefinedWritability(ChannelHandlerContext ctx, boolean writable){
	...
		... ctx.channelUnsafeOutboundBuffer();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void channelUnsafeOutboundBuffer(){
	...
		... channel().unsafeOutboundBuffer();
	...
	}
...
}

public class Channel{
...
	public void unsafeOutboundBuffer(){
	...
		... unsafe().outboundBuffer();
	...
	}
...
}


----------------------------------
83. OurMessageChain{ ctx.channel().config().isAutoRead(), degree= 3, category= LOW, containerMethod= readIfNeeded(), containerClass= ProxyHandler}
-----

public class ProxyHandler{
...
	private static void readIfNeeded(ChannelHandlerContext ctx){
	...
		... ctx.channelConfigIsAutoRead();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelConfigIsAutoRead(){
	...
		... channel().configIsAutoRead();
	...
	}
...
}

public class Channel{
...
	public boolean configIsAutoRead(){
	...
		... config().isAutoRead();
	...
	}
...
}


----------------------------------
84. OurMessageChain{ buf.writeByte(CR).writeByte(LF).resetWriterIndex(), degree= 3, category= LOW, containerMethod= chainedBytes2(), containerClass= WriteBytesVsShortOrMediumBenchmark}
-----

public class WriteBytesVsShortOrMediumBenchmark{
...
	public ByteBuf chainedBytes2(){
	...
		... buf.writeByteWriteByteResetWriterIndex();
	...
	}
...
}

public class ByteBuf{
...
	public ByteBuf writeByteWriteByteResetWriterIndex(){
	...
		... writeByte(CR).writeByteResetWriterIndex();
	...
	}
...
}

public class ByteBuf{
...
	public ByteBuf writeByteResetWriterIndex(){
	...
		... writeByte(LF).resetWriterIndex();
	...
	}
...
}


----------------------------------
85. OurMessageChain{ chan.pipeline().writeAndFlush(abyte.retainedSlice()).sync(), degree= 3, category= LOW, containerMethod= pingPong(), containerClass= EpollSocketChannelBenchmark}
-----

public class EpollSocketChannelBenchmark{
...
	public Object pingPong() throws Exception{
	...
		... chan.pipelineWriteAndFlushSync();
	...
	}
...
}


----------------------------------
86. OurMessageChain{ ctx.pipeline.estimatorHandle().size(msg), degree= 3, category= LOW, containerMethod= init(), containerClass= AbstractChannelHandlerContext}
-----

public class AbstractChannelHandlerContext{
...
	protected static void init(AbstractWriteTask task, AbstractChannelHandlerContext ctx, Object msg, ChannelPromise promise){
	...
		... ctx.pipelineEstimatorHandleSize();
	...
	}
...
}


----------------------------------
87. OurMessageChain{ channel.config().getMessageSizeEstimator().newHandle(), degree= 3, category= LOW, containerMethod= estimatorHandle(), containerClass= DefaultChannelPipeline}
-----

public class DefaultChannelPipeline{
...
	final MessageSizeEstimator.Handle estimatorHandle(){
	...
		... channel.configMessageSizeEstimatorNewHandle();
	...
	}
...
}

public class Channel{
...
	public Handle configMessageSizeEstimatorNewHandle(){
	...
		... config().messageSizeEstimatorNewHandle();
	...
	}
...
}

public class ChannelConfig{
...
	public Handle messageSizeEstimatorNewHandle(){
	...
		... getMessageSizeEstimator().newHandle();
	...
	}
...
}


----------------------------------
88. OurMessageChain{ buf.readBytes(length).order(order()), degree= 2, category= LOW, containerMethod= readBytes(), containerClass= SwappedByteBuf}
-----

public class SwappedByteBuf{
...
	public ByteBuf readBytes(int length){
	...
		... buf.readBytesOrder();
	...
	}
...
}

public class ByteBuf{
...
	public ByteOrder readBytesOrder(){
	...
		... readBytes(length).order();
	...
	}
...
}


----------------------------------
89. OurMessageChain{ buf.readSlice(length).order(order), degree= 2, category= LOW, containerMethod= readSlice(), containerClass= SwappedByteBuf}
-----

public class SwappedByteBuf{
...
	public ByteBuf readSlice(int length){
	...
		... buf.readSliceOrder();
	...
	}
...
}

public class ByteBuf{
...
	public ByteOrder readSliceOrder(){
	...
		... readSlice(length).order();
	...
	}
...
}


----------------------------------
90. OurMessageChain{ buf.readRetainedSlice(length).order(order), degree= 2, category= LOW, containerMethod= readRetainedSlice(), containerClass= SwappedByteBuf}
-----

public class SwappedByteBuf{
...
	public ByteBuf readRetainedSlice(int length){
	...
		... buf.readRetainedSliceOrder();
	...
	}
...
}

public class ByteBuf{
...
	public ByteOrder readRetainedSliceOrder(){
	...
		... readRetainedSlice(length).order();
	...
	}
...
}


----------------------------------
91. OurMessageChain{ buf.copy().order(order), degree= 2, category= LOW, containerMethod= copy(), containerClass= SwappedByteBuf}
-----

public class SwappedByteBuf{
...
	public ByteBuf copy(){
	...
		... buf.copyOrder();
	...
	}
...
}

public class ByteBuf{
...
	public ByteOrder copyOrder(){
	...
		... copy().order();
	...
	}
...
}


----------------------------------
92. OurMessageChain{ buf.copy(index, length).order(order), degree= 2, category= LOW, containerMethod= copy(), containerClass= SwappedByteBuf}
-----

public class SwappedByteBuf{
...
	public ByteBuf copy(int index, int length){
	...
		... buf.copyOrder();
	...
	}
...
}

public class ByteBuf{
...
	public ByteOrder copyOrder(){
	...
		... copy(index, length).order();
	...
	}
...
}


----------------------------------
93. OurMessageChain{ buf.slice().order(order), degree= 2, category= LOW, containerMethod= slice(), containerClass= SwappedByteBuf}
-----

public class SwappedByteBuf{
...
	public ByteBuf slice(){
	...
		... buf.sliceOrder();
	...
	}
...
}

public class ByteBuf{
...
	public ByteOrder sliceOrder(){
	...
		... slice().order();
	...
	}
...
}


----------------------------------
94. OurMessageChain{ buf.retainedSlice().order(order), degree= 2, category= LOW, containerMethod= retainedSlice(), containerClass= SwappedByteBuf}
-----

public class SwappedByteBuf{
...
	public ByteBuf retainedSlice(){
	...
		... buf.retainedSliceOrder();
	...
	}
...
}

public class ByteBuf{
...
	public ByteOrder retainedSliceOrder(){
	...
		... retainedSlice().order();
	...
	}
...
}


----------------------------------
95. OurMessageChain{ buf.slice(index, length).order(order), degree= 2, category= LOW, containerMethod= slice(), containerClass= SwappedByteBuf}
-----

public class SwappedByteBuf{
...
	public ByteBuf slice(int index, int length){
	...
		... buf.sliceOrder();
	...
	}
...
}

public class ByteBuf{
...
	public ByteOrder sliceOrder(){
	...
		... slice(index, length).order();
	...
	}
...
}


----------------------------------
96. OurMessageChain{ buf.retainedSlice(index, length).order(order), degree= 2, category= LOW, containerMethod= retainedSlice(), containerClass= SwappedByteBuf}
-----

public class SwappedByteBuf{
...
	public ByteBuf retainedSlice(int index, int length){
	...
		... buf.retainedSliceOrder();
	...
	}
...
}

public class ByteBuf{
...
	public ByteOrder retainedSliceOrder(){
	...
		... retainedSlice(index, length).order();
	...
	}
...
}


----------------------------------
97. OurMessageChain{ buf.duplicate().order(order), degree= 2, category= LOW, containerMethod= duplicate(), containerClass= SwappedByteBuf}
-----

public class SwappedByteBuf{
...
	public ByteBuf duplicate(){
	...
		... buf.duplicateOrder();
	...
	}
...
}

public class ByteBuf{
...
	public ByteOrder duplicateOrder(){
	...
		... duplicate().order();
	...
	}
...
}


----------------------------------
98. OurMessageChain{ buf.retainedDuplicate().order(order), degree= 2, category= LOW, containerMethod= retainedDuplicate(), containerClass= SwappedByteBuf}
-----

public class SwappedByteBuf{
...
	public ByteBuf retainedDuplicate(){
	...
		... buf.retainedDuplicateOrder();
	...
	}
...
}

public class ByteBuf{
...
	public ByteOrder retainedDuplicateOrder(){
	...
		... retainedDuplicate().order();
	...
	}
...
}


----------------------------------
99. OurMessageChain{ buf.nioBuffer().order(order), degree= 2, category= LOW, containerMethod= nioBuffer(), containerClass= SwappedByteBuf}
-----

public class SwappedByteBuf{
...
	public ByteBuffer nioBuffer(){
	...
		... buf.nioBufferOrder();
	...
	}
...
}

public class ByteBuf{
...
	public void nioBufferOrder(){
	...
		... nioBuffer().order();
	...
	}
...
}


----------------------------------
100. OurMessageChain{ buf.nioBuffer(index, length).order(order), degree= 2, category= LOW, containerMethod= nioBuffer(), containerClass= SwappedByteBuf}
-----

public class SwappedByteBuf{
...
	public ByteBuffer nioBuffer(int index, int length){
	...
		... buf.nioBufferOrder();
	...
	}
...
}

public class ByteBuf{
...
	public void nioBufferOrder(){
	...
		... nioBuffer(index, length).order();
	...
	}
...
}


----------------------------------
101. OurMessageChain{ ctx.executor().schedule(new Runnable() {

    @Override
    public void run() {
        ctx.close(promise);
    }
}, 10, // FIXME: Magic number
TimeUnit.SECONDS), degree= 2, category= LOW, containerMethod= close(), containerClass= Bzip2Encoder}
-----

public class Bzip2Encoder{
...
	public void close(final ChannelHandlerContext ctx, final ChannelPromise promise) throws Exception{
	...
		... ctx.executorSchedule();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void executorSchedule(){
	...
		... executor().schedule();
	...
	}
...
}


----------------------------------
102. OurMessageChain{ ctx.alloc().buffer(), degree= 2, category= LOW, containerMethod= finishEncode(), containerClass= Bzip2Encoder}
-----

public class Bzip2Encoder{
...
	private ChannelFuture finishEncode(final ChannelHandlerContext ctx, ChannelPromise promise){
	...
		... ctx.allocBuffer();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public ByteBuf allocBuffer(){
	...
		... alloc().buffer();
	...
	}
...
}


----------------------------------
103. OurMessageChain{ ctx.alloc().heapBuffer(sizeEstimate), degree= 2, category= LOW, containerMethod= allocateBuffer(), containerClass= JdkZlibEncoder}
-----

public class JdkZlibEncoder{
...
	protected final ByteBuf allocateBuffer(ChannelHandlerContext ctx, ByteBuf msg, boolean preferDirect) throws Exception{
	...
		... ctx.allocHeapBuffer();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public ByteBuf allocHeapBuffer(){
	...
		... alloc().heapBuffer();
	...
	}
...
}


----------------------------------
104. OurMessageChain{ ctx.executor().schedule(new Runnable() {

    @Override
    public void run() {
        ctx.close(promise);
    }
}, 10, // FIXME: Magic number
TimeUnit.SECONDS), degree= 2, category= LOW, containerMethod= close(), containerClass= JdkZlibEncoder}
-----

public class JdkZlibEncoder{
...
	public void close(final ChannelHandlerContext ctx, final ChannelPromise promise) throws Exception{
	...
		... ctx.executorSchedule();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void executorSchedule(){
	...
		... executor().schedule();
	...
	}
...
}


----------------------------------
105. OurMessageChain{ ctx.alloc().heapBuffer(), degree= 2, category= LOW, containerMethod= finishEncode(), containerClass= JdkZlibEncoder}
-----

public class JdkZlibEncoder{
...
	private ChannelFuture finishEncode(final ChannelHandlerContext ctx, ChannelPromise promise){
	...
		... ctx.allocHeapBuffer();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public ByteBuf allocHeapBuffer(){
	...
		... alloc().heapBuffer();
	...
	}
...
}


----------------------------------
106. OurMessageChain{ ctx.alloc().heapBuffer(), degree= 2, category= LOW, containerMethod= finishEncode(), containerClass= JdkZlibEncoder}
-----

public class JdkZlibEncoder{
...
	private ChannelFuture finishEncode(final ChannelHandlerContext ctx, ChannelPromise promise){
	...
		... ctx.allocHeapBuffer();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public ByteBuf allocHeapBuffer(){
	...
		... alloc().heapBuffer();
	...
	}
...
}


----------------------------------
107. OurMessageChain{ ctx.executor().schedule(new Runnable() {

    @Override
    public void run() {
        ctx.close(promise);
    }
}, 10, // FIXME: Magic number
TimeUnit.SECONDS), degree= 2, category= LOW, containerMethod= close(), containerClass= JZlibEncoder}
-----

public class JZlibEncoder{
...
	public void close(final ChannelHandlerContext ctx, final ChannelPromise promise){
	...
		... ctx.executorSchedule();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void executorSchedule(){
	...
		... executor().schedule();
	...
	}
...
}


----------------------------------
108. OurMessageChain{ ctx.alloc().heapBuffer(targetBufSize, targetBufSize), degree= 2, category= LOW, containerMethod= allocateBuffer(), containerClass= Lz4FrameEncoder}
-----

public class Lz4FrameEncoder{
...
	private ByteBuf allocateBuffer(ChannelHandlerContext ctx, ByteBuf msg, boolean preferDirect, boolean allowEmptyReturn){
	...
		... ctx.allocHeapBuffer();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public ByteBuf allocHeapBuffer(){
	...
		... alloc().heapBuffer();
	...
	}
...
}


----------------------------------
109. OurMessageChain{ ctx.alloc().ioBuffer(targetBufSize, targetBufSize), degree= 2, category= LOW, containerMethod= allocateBuffer(), containerClass= Lz4FrameEncoder}
-----

public class Lz4FrameEncoder{
...
	private ByteBuf allocateBuffer(ChannelHandlerContext ctx, ByteBuf msg, boolean preferDirect, boolean allowEmptyReturn){
	...
		... ctx.allocIoBuffer();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public ByteBuf allocIoBuffer(){
	...
		... alloc().ioBuffer();
	...
	}
...
}


----------------------------------
110. OurMessageChain{ ctx.alloc().heapBuffer(compressor.maxCompressedLength(buffer.readableBytes()) + HEADER_LENGTH), degree= 2, category= LOW, containerMethod= finishEncode(), containerClass= Lz4FrameEncoder}
-----

public class Lz4FrameEncoder{
...
	private ChannelFuture finishEncode(final ChannelHandlerContext ctx, ChannelPromise promise){
	...
		... ctx.allocHeapBuffer();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public ByteBuf allocHeapBuffer(){
	...
		... alloc().heapBuffer();
	...
	}
...
}


----------------------------------
111. OurMessageChain{ ctx.executor().schedule(new Runnable() {

    @Override
    public void run() {
        ctx.close(promise);
    }
}, 10, // FIXME: Magic number
TimeUnit.SECONDS), degree= 2, category= LOW, containerMethod= close(), containerClass= Lz4FrameEncoder}
-----

public class Lz4FrameEncoder{
...
	public void close(final ChannelHandlerContext ctx, final ChannelPromise promise) throws Exception{
	...
		... ctx.executorSchedule();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void executorSchedule(){
	...
		... executor().schedule();
	...
	}
...
}


----------------------------------
112. OurMessageChain{ ctx.alloc().compositeBuffer(maxCumulationBufferComponents), degree= 2, category= LOW, containerMethod= decode(), containerClass= MessageAggregator}
-----

public class MessageAggregator{
...
	protected void decode(final ChannelHandlerContext ctx, I msg, List<Object> out) throws Exception{
	...
		... ctx.allocCompositeBuffer();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public CompositeByteBuf allocCompositeBuffer(){
	...
		... alloc().compositeBuffer();
	...
	}
...
}


----------------------------------
113. OurMessageChain{ that.type().intValue(), degree= 2, category= LOW, containerMethod= equals(), containerClass= AbstractDnsRecord}
-----

public class AbstractDnsRecord{
...
	public boolean equals(Object obj){
	...
		... that.typeIntValue();
	...
	}
...
}

public class DnsRecord{
...
	public int typeIntValue(){
	...
		... type().intValue();
	...
	}
...
}


----------------------------------
114. OurMessageChain{ content.trailingHeaders().set(trailingHeaders()), degree= 2, category= LOW, containerMethod= copy(), containerClass= ComposedLastHttpContent}
-----

public class ComposedLastHttpContent{
...
	public LastHttpContent copy(){
	...
		... content.trailingHeadersSet();
	...
	}
...
}

public class LastHttpContent{
...
	public HttpHeaders trailingHeadersSet(){
	...
		... trailingHeaders().set();
	...
	}
...
}


----------------------------------
115. OurMessageChain{ dup.trailingHeaders().setAll(trailingHeaders()), degree= 2, category= LOW, containerMethod= replace(), containerClass= ComposedLastHttpContent}
-----

public class ComposedLastHttpContent{
...
	public LastHttpContent replace(ByteBuf content){
	...
		... dup.trailingHeadersSetAll();
	...
	}
...
}

public class LastHttpContent{
...
	public HttpHeaders trailingHeadersSetAll(){
	...
		... trailingHeaders().setAll();
	...
	}
...
}


----------------------------------
116. OurMessageChain{ corsConfig.origins().contains(requestOrigin), degree= 2, category= LOW, containerMethod= getForOrigin(), containerClass= CorsHandler}
-----

public class CorsHandler{
...
	private CorsConfig getForOrigin(String requestOrigin){
	...
		... corsConfig.originsContains();
	...
	}
...
}

public class CorsConfig{
...
	public void originsContains(){
	...
		... origins().contains();
	...
	}
...
}


----------------------------------
117. OurMessageChain{ config.origins().contains(origin), degree= 2, category= LOW, containerMethod= setOrigin(), containerClass= CorsHandler}
-----

public class CorsHandler{
...
	private boolean setOrigin(final HttpResponse response){
	...
		... config.originsContains();
	...
	}
...
}

public class CorsConfig{
...
	public void originsContains(){
	...
		... origins().contains();
	...
	}
...
}


----------------------------------
118. OurMessageChain{ request.method().equals(OPTIONS), degree= 2, category= LOW, containerMethod= isPreflightRequest(), containerClass= CorsHandler}
-----

public class CorsHandler{
...
	private static boolean isPreflightRequest(final HttpRequest request){
	...
		... request.methodEquals();
	...
	}
...
}

public class HttpRequest{
...
	public boolean methodEquals(){
	...
		... method().equals();
	...
	}
...
}


----------------------------------
119. OurMessageChain{ config.exposedHeaders().isEmpty(), degree= 2, category= LOW, containerMethod= setExposeHeaders(), containerClass= CorsHandler}
-----

public class CorsHandler{
...
	private void setExposeHeaders(final HttpResponse response){
	...
		... config.exposedHeadersIsEmpty();
	...
	}
...
}

public class CorsConfig{
...
	public void exposedHeadersIsEmpty(){
	...
		... exposedHeaders().isEmpty();
	...
	}
...
}


----------------------------------
120. OurMessageChain{ dup.trailingHeaders().set(trailingHeaders()), degree= 2, category= LOW, containerMethod= replace(), containerClass= DefaultLastHttpContent}
-----

public class DefaultLastHttpContent{
...
	public LastHttpContent replace(ByteBuf content){
	...
		... dup.trailingHeadersSet();
	...
	}
...
}

public class DefaultLastHttpContent{
...
	public HttpHeaders trailingHeadersSet(){
	...
		... trailingHeaders().set();
	...
	}
...
}


----------------------------------
121. OurMessageChain{ method.name().charAt(0), degree= 2, category= LOW, containerMethod= isContentAlwaysEmpty(), containerClass= HttpClientCodec}
-----

public class HttpClientCodec{
...
	protected boolean isContentAlwaysEmpty(HttpMessage msg){
	...
		... method.nameCharAt();
	...
	}
...
}

public class HttpMethod{
...
	public void nameCharAt(){
	...
		... name().charAt();
	...
	}
...
}


----------------------------------
122. OurMessageChain{ ctx.channel().id(), degree= 2, category= LOW, containerMethod= beginEncode(), containerClass= HttpContentCompressor}
-----

public class HttpContentCompressor{
...
	protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception{
	...
		... ctx.channelId();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public ChannelId channelId(){
	...
		... channel().id();
	...
	}
...
}


----------------------------------
123. OurMessageChain{ ctx.channel().config(), degree= 2, category= LOW, containerMethod= beginEncode(), containerClass= HttpContentCompressor}
-----

public class HttpContentCompressor{
...
	protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception{
	...
		... ctx.channelConfig();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public ChannelConfig channelConfig(){
	...
		... channel().config();
	...
	}
...
}


----------------------------------
124. OurMessageChain{ copy.headers().set(message.headers()), degree= 2, category= LOW, containerMethod= decode(), containerClass= HttpContentDecoder}
-----

public class HttpContentDecoder{
...
	protected void decode(ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception{
	...
		... copy.headersSet();
	...
	}
...
}

public class HttpMessage{
...
	public HttpHeaders headersSet(){
	...
		... headers().set();
	...
	}
...
}


----------------------------------
125. OurMessageChain{ res.status().code(), degree= 2, category= LOW, containerMethod= encode(), containerClass= HttpContentEncoder}
-----

public class HttpContentEncoder{
...
	protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception{
	...
		... res.statusCode();
	...
	}
...
}

public class HttpResponse{
...
	public int statusCode(){
	...
		... status().code();
	...
	}
...
}


----------------------------------
126. OurMessageChain{ res.status().code(), degree= 2, category= LOW, containerMethod= isContentAlwaysEmpty(), containerClass= HttpObjectDecoder}
-----

public class HttpObjectDecoder{
...
	protected boolean isContentAlwaysEmpty(HttpMessage msg){
	...
		... res.statusCode();
	...
	}
...
}

public class HttpResponse{
...
	public int statusCode(){
	...
		... status().code();
	...
	}
...
}


----------------------------------
127. OurMessageChain{ line.toString().trim(), degree= 2, category= LOW, containerMethod= readHeaders(), containerClass= HttpObjectDecoder}
-----

public class HttpObjectDecoder{
...
	private State readHeaders(ByteBuf buffer){
	...
		... line.toStringTrim();
	...
	}
...
}

public class AppendableCharSequence{
...
	public void toStringTrim(){
	...
		... toString().trim();
	...
	}
...
}


----------------------------------
128. OurMessageChain{ trailer.trailingHeaders().add(headerName, value), degree= 2, category= LOW, containerMethod= readTrailingHeaders(), containerClass= HttpObjectDecoder}
-----

public class HttpObjectDecoder{
...
	private LastHttpContent readTrailingHeaders(ByteBuf buffer){
	...
		... trailer.trailingHeadersAdd();
	...
	}
...
}

public class LastHttpContent{
...
	public HttpHeaders trailingHeadersAdd(){
	...
		... trailingHeaders().add();
	...
	}
...
}


----------------------------------
129. OurMessageChain{ trailer.trailingHeaders().getAll(lastHeader), degree= 2, category= LOW, containerMethod= readTrailingHeaders(), containerClass= HttpObjectDecoder}
-----

public class HttpObjectDecoder{
...
	private LastHttpContent readTrailingHeaders(ByteBuf buffer){
	...
		... trailer.trailingHeadersAll();
	...
	}
...
}

public class LastHttpContent{
...
	public List<String> trailingHeadersAll(){
	...
		... trailingHeaders().getAll();
	...
	}
...
}


----------------------------------
130. OurMessageChain{ line.toString().trim(), degree= 2, category= LOW, containerMethod= readTrailingHeaders(), containerClass= HttpObjectDecoder}
-----

public class HttpObjectDecoder{
...
	private LastHttpContent readTrailingHeaders(ByteBuf buffer){
	...
		... line.toStringTrim();
	...
	}
...
}

public class AppendableCharSequence{
...
	public void toStringTrim(){
	...
		... toString().trim();
	...
	}
...
}


----------------------------------
131. OurMessageChain{ responseStatus.reasonPhrase().contentEquals(reasonPhrase), degree= 2, category= LOW, containerMethod= valueOf(), containerClass= HttpResponseStatus}
-----

public class HttpResponseStatus{
...
	public static HttpResponseStatus valueOf(int code, String reasonPhrase){
	...
		... responseStatus.reasonPhraseContentEquals();
	...
	}
...
}

public class HttpResponseStatus{
...
	public void reasonPhraseContentEquals(){
	...
		... reasonPhrase().contentEquals();
	...
	}
...
}


----------------------------------
132. OurMessageChain{ other.name().equals(name), degree= 2, category= LOW, containerMethod= equals(), containerClass= HttpScheme}
-----

public class HttpScheme{
...
	public boolean equals(Object o){
	...
		... other.nameEquals();
	...
	}
...
}

public class HttpScheme{
...
	public boolean nameEquals(){
	...
		... name().equals();
	...
	}
...
}


----------------------------------
133. OurMessageChain{ res.status().code(), degree= 2, category= LOW, containerMethod= getWebSocketContentLength(), containerClass= HttpUtil}
-----

public class HttpUtil{
...
	private static int getWebSocketContentLength(HttpMessage message){
	...
		... res.statusCode();
	...
	}
...
}

public class HttpResponse{
...
	public int statusCode(){
	...
		... status().code();
	...
	}
...
}


----------------------------------
134. OurMessageChain{ encoding.getValue().toLowerCase(), degree= 2, category= LOW, containerMethod= getFileUpload(), containerClass= HttpPostMultipartRequestDecoder}
-----

public class HttpPostMultipartRequestDecoder{
...
	protected InterfaceHttpData getFileUpload(String delimiter){
	...
		... encoding.valueToLowerCase();
	...
	}
...
}

public class Attribute{
...
	public void valueToLowerCase(){
	...
		... getValue().toLowerCase();
	...
	}
...
}


----------------------------------
135. OurMessageChain{ fileUpload.getFilename().isEmpty(), degree= 2, category= LOW, containerMethod= addBodyHttpData(), containerClass= HttpPostRequestEncoder}
-----

public class HttpPostRequestEncoder{
...
	public void addBodyHttpData(InterfaceHttpData data) throws ErrorDataEncoderException{
	...
		... fileUpload.filenameIsEmpty();
	...
	}
...
}

public class FileUpload{
...
	public void filenameIsEmpty(){
	...
		... getFilename().isEmpty();
	...
	}
...
}


----------------------------------
136. OurMessageChain{ fileUpload.getFilename().isEmpty(), degree= 2, category= LOW, containerMethod= addBodyHttpData(), containerClass= HttpPostRequestEncoder}
-----

public class HttpPostRequestEncoder{
...
	public void addBodyHttpData(InterfaceHttpData data) throws ErrorDataEncoderException{
	...
		... fileUpload.filenameIsEmpty();
	...
	}
...
}

public class FileUpload{
...
	public void filenameIsEmpty(){
	...
		... getFilename().isEmpty();
	...
	}
...
}


----------------------------------
137. OurMessageChain{ fileUpload.getFilename().isEmpty(), degree= 2, category= LOW, containerMethod= addBodyHttpData(), containerClass= HttpPostRequestEncoder}
-----

public class HttpPostRequestEncoder{
...
	public void addBodyHttpData(InterfaceHttpData data) throws ErrorDataEncoderException{
	...
		... fileUpload.filenameIsEmpty();
	...
	}
...
}

public class FileUpload{
...
	public void filenameIsEmpty(){
	...
		... getFilename().isEmpty();
	...
	}
...
}


----------------------------------
138. OurMessageChain{ duplicate.trailingHeaders().set(trailingHeaders()), degree= 2, category= LOW, containerMethod= replace(), containerClass= HttpPostRequestEncoder}
-----

public class HttpPostRequestEncoder{
...
	public FullHttpRequest replace(ByteBuf content){
	...
		... duplicate.trailingHeadersSet();
	...
	}
...
}

public class DefaultFullHttpRequest{
...
	public HttpHeaders trailingHeadersSet(){
	...
		... trailingHeaders().set();
	...
	}
...
}


----------------------------------
139. OurMessageChain{ handshaker.handshake(ctx.channel()).addListener(new ChannelFutureListener() {

    @Override
    public void operationComplete(ChannelFuture future) throws Exception {
        if (!future.isSuccess()) {
            ctx.fireExceptionCaught(future.cause());
        } else {
            ctx.fireUserEventTriggered(WebSocketClientProtocolHandler.ClientHandshakeStateEvent.HANDSHAKE_ISSUED);
        }
    }
}), degree= 2, category= LOW, containerMethod= channelActive(), containerClass= WebSocketClientProtocolHandshakeHandler}
-----

public class WebSocketClientProtocolHandshakeHandler{
...
	public void channelActive(final ChannelHandlerContext ctx) throws Exception{
	...
		... handshaker.handshakeAddListener();
	...
	}
...
}

public class WebSocketClientHandshaker{
...
	public ChannelFuture handshakeAddListener(){
	...
		... handshake(ctx.channel()).addListener();
	...
	}
...
}


----------------------------------
140. OurMessageChain{ other.name().equals(name), degree= 2, category= LOW, containerMethod= equals(), containerClass= WebSocketScheme}
-----

public class WebSocketScheme{
...
	public boolean equals(Object o){
	...
		... other.nameEquals();
	...
	}
...
}

public class WebSocketScheme{
...
	public boolean nameEquals(){
	...
		... name().equals();
	...
	}
...
}


----------------------------------
141. OurMessageChain{ p.context(HttpResponseEncoder.class).name(), degree= 2, category= LOW, containerMethod= handshake(), containerClass= WebSocketServerHandshaker}
-----

public class WebSocketServerHandshaker{
...
	public final ChannelFuture handshake(Channel channel, FullHttpRequest req, HttpHeaders responseHeaders, final ChannelPromise promise){
	...
		... p.contextName();
	...
	}
...
}

public class ChannelPipeline{
...
	public String contextName(){
	...
		... context(HttpResponseEncoder.class).name();
	...
	}
...
}


----------------------------------
142. OurMessageChain{ spdyDataFrame.content().readableBytes(), degree= 2, category= LOW, containerMethod= decode(), containerClass= SpdyHttpDecoder}
-----

public class SpdyHttpDecoder{
...
	protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, List<Object> out) throws Exception{
	...
		... spdyDataFrame.contentReadableBytes();
	...
	}
...
}

public class SpdyDataFrame{
...
	public int contentReadableBytes(){
	...
		... content().readableBytes();
	...
	}
...
}


----------------------------------
143. OurMessageChain{ spdyHeadersFrame.headers().add(headerName, entry.getValue()), degree= 2, category= LOW, containerMethod= encode(), containerClass= SpdyHttpEncoder}
-----

public class SpdyHttpEncoder{
...
	protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception{
	...
		... spdyHeadersFrame.headersAdd();
	...
	}
...
}

public class SpdyHeadersFrame{
...
	public void headersAdd(){
	...
		... headers().add();
	...
	}
...
}


----------------------------------
144. OurMessageChain{ spdyHeadersFrame.headers().add(headerName, entry.getValue()), degree= 2, category= LOW, containerMethod= createHeadersFrame(), containerClass= SpdyHttpEncoder}
-----

public class SpdyHttpEncoder{
...
	private SpdyHeadersFrame createHeadersFrame(HttpResponse httpResponse) throws Exception{
	...
		... spdyHeadersFrame.headersAdd();
	...
	}
...
}

public class SpdyHeadersFrame{
...
	public void headersAdd(){
	...
		... headers().add();
	...
	}
...
}


----------------------------------
145. OurMessageChain{ spdyDataFrame.content().readableBytes(), degree= 2, category= LOW, containerMethod= channelRead(), containerClass= SpdySessionHandler}
-----

public class SpdySessionHandler{
...
	public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception{
	...
		... spdyDataFrame.contentReadableBytes();
	...
	}
...
}

public class SpdyDataFrame{
...
	public int contentReadableBytes(){
	...
		... content().readableBytes();
	...
	}
...
}


----------------------------------
146. OurMessageChain{ spdyDataFrame.content().readRetainedSlice(initialReceiveWindowSize), degree= 2, category= LOW, containerMethod= channelRead(), containerClass= SpdySessionHandler}
-----

public class SpdySessionHandler{
...
	public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception{
	...
		... spdyDataFrame.contentReadRetainedSlice();
	...
	}
...
}

public class SpdyDataFrame{
...
	public ByteBuf contentReadRetainedSlice(){
	...
		... content().readRetainedSlice();
	...
	}
...
}


----------------------------------
147. OurMessageChain{ spdyDataFrame.content().readableBytes(), degree= 2, category= LOW, containerMethod= channelRead(), containerClass= SpdySessionHandler}
-----

public class SpdySessionHandler{
...
	public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception{
	...
		... spdyDataFrame.contentReadableBytes();
	...
	}
...
}

public class SpdyDataFrame{
...
	public int contentReadableBytes(){
	...
		... content().readableBytes();
	...
	}
...
}


----------------------------------
148. OurMessageChain{ spdySession.activeStreams().keySet(), degree= 2, category= LOW, containerMethod= channelInactive(), containerClass= SpdySessionHandler}
-----

public class SpdySessionHandler{
...
	public void channelInactive(ChannelHandlerContext ctx) throws Exception{
	...
		... spdySession.activeStreamsKeySet();
	...
	}
...
}

public class SpdySession{
...
	public void activeStreamsKeySet(){
	...
		... activeStreams().keySet();
	...
	}
...
}


----------------------------------
149. OurMessageChain{ spdyDataFrame.content().readableBytes(), degree= 2, category= LOW, containerMethod= handleOutboundMessage(), containerClass= SpdySessionHandler}
-----

public class SpdySessionHandler{
...
	private void handleOutboundMessage(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception{
	...
		... spdyDataFrame.contentReadableBytes();
	...
	}
...
}

public class SpdyDataFrame{
...
	public int contentReadableBytes(){
	...
		... content().readableBytes();
	...
	}
...
}


----------------------------------
150. OurMessageChain{ spdyDataFrame.content().readRetainedSlice(sendWindowSize), degree= 2, category= LOW, containerMethod= handleOutboundMessage(), containerClass= SpdySessionHandler}
-----

public class SpdySessionHandler{
...
	private void handleOutboundMessage(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception{
	...
		... spdyDataFrame.contentReadRetainedSlice();
	...
	}
...
}

public class SpdyDataFrame{
...
	public ByteBuf contentReadRetainedSlice(){
	...
		... content().readRetainedSlice();
	...
	}
...
}


----------------------------------
151. OurMessageChain{ spdyDataFrame.content().readableBytes(), degree= 2, category= LOW, containerMethod= updateSendWindowSize(), containerClass= SpdySessionHandler}
-----

public class SpdySessionHandler{
...
	private void updateSendWindowSize(final ChannelHandlerContext ctx, int streamId, int deltaWindowSize){
	...
		... spdyDataFrame.contentReadableBytes();
	...
	}
...
}

public class SpdyDataFrame{
...
	public int contentReadableBytes(){
	...
		... content().readableBytes();
	...
	}
...
}


----------------------------------
152. OurMessageChain{ spdyDataFrame.content().readRetainedSlice(sendWindowSize), degree= 2, category= LOW, containerMethod= updateSendWindowSize(), containerClass= SpdySessionHandler}
-----

public class SpdySessionHandler{
...
	private void updateSendWindowSize(final ChannelHandlerContext ctx, int streamId, int deltaWindowSize){
	...
		... spdyDataFrame.contentReadRetainedSlice();
	...
	}
...
}

public class SpdyDataFrame{
...
	public ByteBuf contentReadRetainedSlice(){
	...
		... content().readRetainedSlice();
	...
	}
...
}


----------------------------------
153. OurMessageChain{ ctx.channel().isActive(), degree= 2, category= LOW, containerMethod= sendGoAwayFrame(), containerClass= SpdySessionHandler}
-----

public class SpdySessionHandler{
...
	private void sendGoAwayFrame(ChannelHandlerContext ctx, ChannelPromise future){
	...
		... ctx.channelIsActive();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelIsActive(){
	...
		... channel().isActive();
	...
	}
...
}


----------------------------------
154. OurMessageChain{ connection.local().flowController(), degree= 2, category= LOW, containerMethod= flowController(), containerClass= DefaultHttp2ConnectionDecoder}
-----

public class DefaultHttp2ConnectionDecoder{
...
	public final Http2LocalFlowController flowController(){
	...
		... connection.localFlowController();
	...
	}
...
}

public class Http2Connection{
...
	public void localFlowController(){
	...
		... local().flowController();
	...
	}
...
}


----------------------------------
155. OurMessageChain{ connection.remote().createStream(streamId, endOfStream), degree= 2, category= LOW, containerMethod= onHeadersRead(), containerClass= DefaultHttp2ConnectionDecoder}
-----

public class DefaultHttp2ConnectionDecoder{
...
	public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int streamDependency, short weight, boolean exclusive, int padding, boolean endOfStream) throws Http2Exception{
	...
		... connection.remoteCreateStream();
	...
	}
...
}

public class Http2Connection{
...
	public void remoteCreateStream(){
	...
		... remote().createStream();
	...
	}
...
}


----------------------------------
156. OurMessageChain{ encoder.flowController().updateDependencyTree(streamId, streamDependency, weight, exclusive), degree= 2, category= LOW, containerMethod= onHeadersRead(), containerClass= DefaultHttp2ConnectionDecoder}
-----

public class DefaultHttp2ConnectionDecoder{
...
	public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int streamDependency, short weight, boolean exclusive, int padding, boolean endOfStream) throws Http2Exception{
	...
		... encoder.flowControllerUpdateDependencyTree();
	...
	}
...
}

public class Http2ConnectionEncoder{
...
	public void flowControllerUpdateDependencyTree(){
	...
		... flowController().updateDependencyTree();
	...
	}
...
}


----------------------------------
157. OurMessageChain{ encoder.flowController().updateDependencyTree(streamId, streamDependency, weight, exclusive), degree= 2, category= LOW, containerMethod= onPriorityRead(), containerClass= DefaultHttp2ConnectionDecoder}
-----

public class DefaultHttp2ConnectionDecoder{
...
	public void onPriorityRead(ChannelHandlerContext ctx, int streamId, int streamDependency, short weight, boolean exclusive) throws Http2Exception{
	...
		... encoder.flowControllerUpdateDependencyTree();
	...
	}
...
}

public class Http2ConnectionEncoder{
...
	public void flowControllerUpdateDependencyTree(){
	...
		... flowController().updateDependencyTree();
	...
	}
...
}


----------------------------------
158. OurMessageChain{ connection.local().allowPushTo(pushEnabled), degree= 2, category= LOW, containerMethod= applyLocalSettings(), containerClass= DefaultHttp2ConnectionDecoder}
-----

public class DefaultHttp2ConnectionDecoder{
...
	private void applyLocalSettings(Http2Settings settings) throws Http2Exception{
	...
		... connection.localAllowPushTo();
	...
	}
...
}

public class Http2Connection{
...
	public void localAllowPushTo(){
	...
		... local().allowPushTo();
	...
	}
...
}


----------------------------------
159. OurMessageChain{ connection.remote().maxActiveStreams((int) min(maxConcurrentStreams, MAX_VALUE)), degree= 2, category= LOW, containerMethod= applyLocalSettings(), containerClass= DefaultHttp2ConnectionDecoder}
-----

public class DefaultHttp2ConnectionDecoder{
...
	private void applyLocalSettings(Http2Settings settings) throws Http2Exception{
	...
		... connection.remoteMaxActiveStreams();
	...
	}
...
}

public class Http2Connection{
...
	public void remoteMaxActiveStreams(){
	...
		... remote().maxActiveStreams();
	...
	}
...
}


----------------------------------
160. OurMessageChain{ connection.remote().reservePushStream(promisedStreamId, parentStream), degree= 2, category= LOW, containerMethod= onPushPromiseRead(), containerClass= DefaultHttp2ConnectionDecoder}
-----

public class DefaultHttp2ConnectionDecoder{
...
	public void onPushPromiseRead(ChannelHandlerContext ctx, int streamId, int promisedStreamId, Http2Headers headers, int padding) throws Http2Exception{
	...
		... connection.remoteReservePushStream();
	...
	}
...
}

public class Http2Connection{
...
	public void remoteReservePushStream(){
	...
		... remote().reservePushStream();
	...
	}
...
}


----------------------------------
161. OurMessageChain{ encoder.flowController().incrementWindowSize(stream, windowSizeIncrement), degree= 2, category= LOW, containerMethod= onWindowUpdateRead(), containerClass= DefaultHttp2ConnectionDecoder}
-----

public class DefaultHttp2ConnectionDecoder{
...
	public void onWindowUpdateRead(ChannelHandlerContext ctx, int streamId, int windowSizeIncrement) throws Http2Exception{
	...
		... encoder.flowControllerIncrementWindowSize();
	...
	}
...
}

public class Http2ConnectionEncoder{
...
	public void flowControllerIncrementWindowSize(){
	...
		... flowController().incrementWindowSize();
	...
	}
...
}


----------------------------------
162. OurMessageChain{ connection.remote().allowPushTo(pushEnabled), degree= 2, category= LOW, containerMethod= remoteSettings(), containerClass= DefaultHttp2ConnectionEncoder}
-----

public class DefaultHttp2ConnectionEncoder{
...
	public void remoteSettings(Http2Settings settings) throws Http2Exception{
	...
		... connection.remoteAllowPushTo();
	...
	}
...
}

public class Http2Connection{
...
	public void remoteAllowPushTo(){
	...
		... remote().allowPushTo();
	...
	}
...
}


----------------------------------
163. OurMessageChain{ connection.local().maxActiveStreams((int) min(maxConcurrentStreams, MAX_VALUE)), degree= 2, category= LOW, containerMethod= remoteSettings(), containerClass= DefaultHttp2ConnectionEncoder}
-----

public class DefaultHttp2ConnectionEncoder{
...
	public void remoteSettings(Http2Settings settings) throws Http2Exception{
	...
		... connection.localMaxActiveStreams();
	...
	}
...
}

public class Http2Connection{
...
	public void localMaxActiveStreams(){
	...
		... local().maxActiveStreams();
	...
	}
...
}


----------------------------------
164. OurMessageChain{ connection.remote().mayHaveCreatedStream(streamId), degree= 2, category= LOW, containerMethod= writeHeaders(), containerClass= DefaultHttp2ConnectionEncoder}
-----

public class DefaultHttp2ConnectionEncoder{
...
	public ChannelFuture writeHeaders(final ChannelHandlerContext ctx, final int streamId, final Http2Headers headers, final int streamDependency, final short weight, final boolean exclusive, final int padding, final boolean endOfStream, ChannelPromise promise){
	...
		... connection.remoteMayHaveCreatedStream();
	...
	}
...
}

public class Http2Connection{
...
	public void remoteMayHaveCreatedStream(){
	...
		... remote().mayHaveCreatedStream();
	...
	}
...
}


----------------------------------
165. OurMessageChain{ connection.local().createStream(streamId, endOfStream), degree= 2, category= LOW, containerMethod= writeHeaders(), containerClass= DefaultHttp2ConnectionEncoder}
-----

public class DefaultHttp2ConnectionEncoder{
...
	public ChannelFuture writeHeaders(final ChannelHandlerContext ctx, final int streamId, final Http2Headers headers, final int streamDependency, final short weight, final boolean exclusive, final int padding, final boolean endOfStream, ChannelPromise promise){
	...
		... connection.localCreateStream();
	...
	}
...
}

public class Http2Connection{
...
	public void localCreateStream(){
	...
		... local().createStream();
	...
	}
...
}


----------------------------------
166. OurMessageChain{ connection.local().reservePushStream(promisedStreamId, stream), degree= 2, category= LOW, containerMethod= writePushPromise(), containerClass= DefaultHttp2ConnectionEncoder}
-----

public class DefaultHttp2ConnectionEncoder{
...
	public ChannelFuture writePushPromise(ChannelHandlerContext ctx, int streamId, int promisedStreamId, Http2Headers headers, int padding, ChannelPromise promise){
	...
		... connection.localReservePushStream();
	...
	}
...
}

public class Http2Connection{
...
	public void localReservePushStream(){
	...
		... local().reservePushStream();
	...
	}
...
}


----------------------------------
167. OurMessageChain{ headersDecoder.configuration().maxHeaderListSizeGoAway(), degree= 2, category= LOW, containerMethod= addFragment(), containerClass= DefaultHttp2FrameReader}
-----

public class DefaultHttp2FrameReader{
...
	final void addFragment(ByteBuf fragment, ByteBufAllocator alloc, boolean endOfHeaders) throws Http2Exception{
	...
		... headersDecoder.configurationMaxHeaderListSizeGoAway();
	...
	}
...
}

public class Http2HeadersDecoder{
...
	public void configurationMaxHeaderListSizeGoAway(){
	...
		... configuration().maxHeaderListSizeGoAway();
	...
	}
...
}


----------------------------------
168. OurMessageChain{ headersDecoder.configuration().maxHeaderListSizeGoAway(), degree= 2, category= LOW, containerMethod= addFragment(), containerClass= DefaultHttp2FrameReader}
-----

public class DefaultHttp2FrameReader{
...
	final void addFragment(ByteBuf fragment, ByteBufAllocator alloc, boolean endOfHeaders) throws Http2Exception{
	...
		... headersDecoder.configurationMaxHeaderListSizeGoAway();
	...
	}
...
}

public class Http2HeadersDecoder{
...
	public void configurationMaxHeaderListSizeGoAway(){
	...
		... configuration().maxHeaderListSizeGoAway();
	...
	}
...
}


----------------------------------
169. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= initialWindowSize(), containerClass= DefaultHttp2LocalFlowController}
-----

public class DefaultHttp2LocalFlowController{
...
	public void initialWindowSize(int newWindowSize) throws Http2Exception{
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
170. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= incrementWindowSize(), containerClass= DefaultHttp2LocalFlowController}
-----

public class DefaultHttp2LocalFlowController{
...
	public void incrementWindowSize(Http2Stream stream, int delta) throws Http2Exception{
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
171. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= consumeBytes(), containerClass= DefaultHttp2LocalFlowController}
-----

public class DefaultHttp2LocalFlowController{
...
	public boolean consumeBytes(Http2Stream stream, int numBytes) throws Http2Exception{
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
172. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= windowUpdateRatio(), containerClass= DefaultHttp2LocalFlowController}
-----

public class DefaultHttp2LocalFlowController{
...
	public void windowUpdateRatio(float ratio){
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
173. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= windowUpdateRatio(), containerClass= DefaultHttp2LocalFlowController}
-----

public class DefaultHttp2LocalFlowController{
...
	public void windowUpdateRatio(Http2Stream stream, float ratio) throws Http2Exception{
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
174. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= receiveFlowControlledFrame(), containerClass= DefaultHttp2LocalFlowController}
-----

public class DefaultHttp2LocalFlowController{
...
	public void receiveFlowControlledFrame(Http2Stream stream, ByteBuf data, int padding, boolean endOfStream) throws Http2Exception{
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
175. OurMessageChain{ connection.connectionStream().getProperty(stateKey), degree= 2, category= LOW, containerMethod= connectionState(), containerClass= DefaultHttp2LocalFlowController}
-----

public class DefaultHttp2LocalFlowController{
...
	private FlowState connectionState(){
	...
		... connection.connectionStreamProperty();
	...
	}
...
}

public class Http2Connection{
...
	public V connectionStreamProperty(){
	...
		... connectionStream().getProperty();
	...
	}
...
}


----------------------------------
176. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= window(), containerClass= DefaultHttp2LocalFlowController}
-----

public class DefaultHttp2LocalFlowController{
...
	public void window(int initialWindowSize){
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
177. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= windowUpdateRatio(), containerClass= DefaultHttp2LocalFlowController}
-----

public class DefaultHttp2LocalFlowController{
...
	public void windowUpdateRatio(float ratio){
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
178. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= initialWindowSize(), containerClass= DefaultHttp2RemoteFlowController}
-----

public class DefaultHttp2RemoteFlowController{
...
	public void initialWindowSize(int newWindowSize) throws Http2Exception{
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
179. OurMessageChain{ ctx.channel().isWritable(), degree= 2, category= LOW, containerMethod= isChannelWritable0(), containerClass= DefaultHttp2RemoteFlowController}
-----

public class DefaultHttp2RemoteFlowController{
...
	private boolean isChannelWritable0(){
	...
		... ctx.channelIsWritable();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelIsWritable(){
	...
		... channel().isWritable();
	...
	}
...
}


----------------------------------
180. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= incrementWindowSize(), containerClass= DefaultHttp2RemoteFlowController}
-----

public class DefaultHttp2RemoteFlowController{
...
	public void incrementWindowSize(Http2Stream stream, int delta) throws Http2Exception{
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
181. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= addFlowControlled(), containerClass= DefaultHttp2RemoteFlowController}
-----

public class DefaultHttp2RemoteFlowController{
...
	public void addFlowControlled(Http2Stream stream, FlowControlled frame){
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
182. OurMessageChain{ connection.local().flowController(), degree= 2, category= LOW, containerMethod= onDataRead(), containerClass= DelegatingDecompressorFrameListener}
-----

public class DelegatingDecompressorFrameListener{
...
	public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding, boolean endOfStream) throws Http2Exception{
	...
		... connection.localFlowController();
	...
	}
...
}

public class Http2Connection{
...
	public void localFlowController(){
	...
		... local().flowController();
	...
	}
...
}


----------------------------------
183. OurMessageChain{ connection.local().flowController(new ConsumedBytesConverter(connection.local().flowController())), degree= 2, category= LOW, containerMethod= initDecompressor(), containerClass= DelegatingDecompressorFrameListener}
-----

public class DelegatingDecompressorFrameListener{
...
	private void initDecompressor(ChannelHandlerContext ctx, int streamId, Http2Headers headers, boolean endOfStream) throws Http2Exception{
	...
		... connection.localFlowController();
	...
	}
...
}

public class Http2Connection{
...
	public void localFlowController(){
	...
		... local().flowController();
	...
	}
...
}


----------------------------------
184. OurMessageChain{ connectionHandler.decoder().localSettings(), degree= 2, category= LOW, containerMethod= getSettingsHeaderValue(), containerClass= Http2ClientUpgradeCodec}
-----

public class Http2ClientUpgradeCodec{
...
	private CharSequence getSettingsHeaderValue(ChannelHandlerContext ctx){
	...
		... connectionHandler.decoderLocalSettings();
	...
	}
...
}

public class Http2ConnectionHandler{
...
	public Http2Settings decoderLocalSettings(){
	...
		... decoder().localSettings();
	...
	}
...
}


----------------------------------
185. OurMessageChain{ encoder.flowController().writePendingBytes(), degree= 2, category= LOW, containerMethod= flush(), containerClass= Http2ConnectionHandler}
-----

public class Http2ConnectionHandler{
...
	public void flush(ChannelHandlerContext ctx){
	...
		... encoder.flowControllerWritePendingBytes();
	...
	}
...
}

public class Http2ConnectionEncoder{
...
	public void flowControllerWritePendingBytes(){
	...
		... flowController().writePendingBytes();
	...
	}
...
}


----------------------------------
186. OurMessageChain{ ctx.channel().isActive(), degree= 2, category= LOW, containerMethod= decode(), containerClass= Http2ConnectionHandler}
-----

public class Http2ConnectionHandler{
...
	public void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception{
	...
		... ctx.channelIsActive();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelIsActive(){
	...
		... channel().isActive();
	...
	}
...
}


----------------------------------
187. OurMessageChain{ ctx.channel().isActive(), degree= 2, category= LOW, containerMethod= sendPreface(), containerClass= Http2ConnectionHandler}
-----

public class Http2ConnectionHandler{
...
	private void sendPreface(ChannelHandlerContext ctx) throws Exception{
	...
		... ctx.channelIsActive();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelIsActive(){
	...
		... channel().isActive();
	...
	}
...
}


----------------------------------
188. OurMessageChain{ encoder.flowController().channelHandlerContext(ctx), degree= 2, category= LOW, containerMethod= handlerAdded(), containerClass= Http2ConnectionHandler}
-----

public class Http2ConnectionHandler{
...
	public void handlerAdded(ChannelHandlerContext ctx) throws Exception{
	...
		... encoder.flowControllerChannelHandlerContext();
	...
	}
...
}

public class Http2ConnectionEncoder{
...
	public ChannelHandlerContext flowControllerChannelHandlerContext(){
	...
		... flowController().channelHandlerContext();
	...
	}
...
}


----------------------------------
189. OurMessageChain{ decoder.flowController().channelHandlerContext(ctx), degree= 2, category= LOW, containerMethod= handlerAdded(), containerClass= Http2ConnectionHandler}
-----

public class Http2ConnectionHandler{
...
	public void handlerAdded(ChannelHandlerContext ctx) throws Exception{
	...
		... decoder.flowControllerChannelHandlerContext();
	...
	}
...
}

public class Http2ConnectionDecoder{
...
	public void flowControllerChannelHandlerContext(){
	...
		... flowController().channelHandlerContext();
	...
	}
...
}


----------------------------------
190. OurMessageChain{ ctx.channel().isWritable(), degree= 2, category= LOW, containerMethod= channelWritabilityChanged(), containerClass= Http2ConnectionHandler}
-----

public class Http2ConnectionHandler{
...
	public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception{
	...
		... ctx.channelIsWritable();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelIsWritable(){
	...
		... channel().isWritable();
	...
	}
...
}


----------------------------------
191. OurMessageChain{ encoder.flowController().channelWritabilityChanged(), degree= 2, category= LOW, containerMethod= channelWritabilityChanged(), containerClass= Http2ConnectionHandler}
-----

public class Http2ConnectionHandler{
...
	public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception{
	...
		... encoder.flowControllerChannelWritabilityChanged();
	...
	}
...
}

public class Http2ConnectionEncoder{
...
	public void flowControllerChannelWritabilityChanged(){
	...
		... flowController().channelWritabilityChanged();
	...
	}
...
}


----------------------------------
192. OurMessageChain{ ctx.channel().isActive(), degree= 2, category= LOW, containerMethod= close(), containerClass= Http2ConnectionHandler}
-----

public class Http2ConnectionHandler{
...
	public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception{
	...
		... ctx.channelIsActive();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelIsActive(){
	...
		... channel().isActive();
	...
	}
...
}


----------------------------------
193. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= forEachActiveStream(), containerClass= Http2FrameCodec}
-----

public class Http2FrameCodec{
...
	final void forEachActiveStream(final Http2FrameStreamVisitor streamVisitor) throws Http2Exception{
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
194. OurMessageChain{ connection.local().incrementAndGetNextStreamId(), degree= 2, category= LOW, containerMethod= writeHeadersFrame(), containerClass= Http2FrameCodec}
-----

public class Http2FrameCodec{
...
	private void writeHeadersFrame(final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame, final ChannelPromise promise){
	...
		... connection.localIncrementAndGetNextStreamId();
	...
	}
...
}

public class Http2Connection{
...
	public void localIncrementAndGetNextStreamId(){
	...
		... local().incrementAndGetNextStreamId();
	...
	}
...
}


----------------------------------
195. OurMessageChain{ childChannel.unsafe().closeForcibly(), degree= 2, category= LOW, containerMethod= registerDone(), containerClass= Http2MultiplexCodec}
-----

public class Http2MultiplexCodec{
...
	private static void registerDone(ChannelFuture future){
	...
		... childChannel.unsafeCloseForcibly();
	...
	}
...
}

public class Channel{
...
	public void unsafeCloseForcibly(){
	...
		... unsafe().closeForcibly();
	...
	}
...
}


----------------------------------
196. OurMessageChain{ ctx.channel().eventLoop(), degree= 2, category= LOW, containerMethod= handlerAdded0(), containerClass= Http2MultiplexCodec}
-----

public class Http2MultiplexCodec{
...
	public final void handlerAdded0(ChannelHandlerContext ctx) throws Exception{
	...
		... ctx.channelEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public EventLoop channelEventLoop(){
	...
		... channel().eventLoop();
	...
	}
...
}


----------------------------------
197. OurMessageChain{ channel.pipeline().context(Http2MultiplexCodec.class), degree= 2, category= LOW, containerMethod= open(), containerClass= Http2StreamChannelBootstrap}
-----

public class Http2StreamChannelBootstrap{
...
	public Future<Http2StreamChannel> open(final Promise<Http2StreamChannel> promise){
	...
		... channel.pipelineContext();
	...
	}
...
}

public class Channel{
...
	public ChannelHandlerContext pipelineContext(){
	...
		... pipeline().context();
	...
	}
...
}


----------------------------------
198. OurMessageChain{ channel.config().setOption((ChannelOption<Object>) option, value), degree= 2, category= LOW, containerMethod= setChannelOption(), containerClass= Http2StreamChannelBootstrap}
-----

public class Http2StreamChannelBootstrap{
...
	private static void setChannelOption(Channel channel, ChannelOption<?> option, Object value, InternalLogger logger){
	...
		... channel.configSetOption();
	...
	}
...
}

public class Channel{
...
	public boolean configSetOption(){
	...
		... config().setOption();
	...
	}
...
}


----------------------------------
199. OurMessageChain{ req.headers().add(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED), degree= 2, category= LOW, containerMethod= decode(), containerClass= Http2StreamFrameToHttpObjectCodec}
-----

public class Http2StreamFrameToHttpObjectCodec{
...
	protected void decode(ChannelHandlerContext ctx, Http2StreamFrame frame, List<Object> out) throws Exception{
	...
		... req.headersAdd();
	...
	}
...
}

public class HttpMessage{
...
	public HttpHeaders headersAdd(){
	...
		... headers().add();
	...
	}
...
}


----------------------------------
200. OurMessageChain{ res.status().equals(HttpResponseStatus.CONTINUE), degree= 2, category= LOW, containerMethod= encode(), containerClass= Http2StreamFrameToHttpObjectCodec}
-----

public class Http2StreamFrameToHttpObjectCodec{
...
	protected void encode(ChannelHandlerContext ctx, HttpObject obj, List<Object> out) throws Exception{
	...
		... res.statusEquals();
	...
	}
...
}

public class HttpResponse{
...
	public boolean statusEquals(){
	...
		... status().equals();
	...
	}
...
}


----------------------------------
201. OurMessageChain{ connChannel.pipeline().get(SslHandler.class), degree= 2, category= LOW, containerMethod= isSsl(), containerClass= Http2StreamFrameToHttpObjectCodec}
-----

public class Http2StreamFrameToHttpObjectCodec{
...
	protected boolean isSsl(final ChannelHandlerContext ctx){
	...
		... connChannel.pipeline();
	...
	}
...
}

public class Channel{
...
	public ChannelHandler pipeline(){
	...
		... pipeline().get();
	...
	}
...
}


----------------------------------
202. OurMessageChain{ connection.remote().createStream(streamId, false), degree= 2, category= LOW, containerMethod= handle(), containerClass= InboundHttpToHttp2Adapter}
-----

public class InboundHttpToHttp2Adapter{
...
	static void handle(ChannelHandlerContext ctx, Http2Connection connection, Http2FrameListener listener, FullHttpMessage message) throws Http2Exception{
	...
		... connection.remoteCreateStream();
	...
	}
...
}

public class Http2Connection{
...
	public void remoteCreateStream(){
	...
		... remote().createStream();
	...
	}
...
}


----------------------------------
203. OurMessageChain{ mqttFixedHeader.qosLevel().value(), degree= 2, category= LOW, containerMethod= decodePublishVariableHeader(), containerClass= MqttDecoder}
-----

public class MqttDecoder{
...
	private static Result<MqttPublishVariableHeader> decodePublishVariableHeader(ByteBuf buffer, MqttFixedHeader mqttFixedHeader){
	...
		... mqttFixedHeader.qosLevelValue();
	...
	}
...
}

public class MqttFixedHeader{
...
	public int qosLevelValue(){
	...
		... qosLevel().value();
	...
	}
...
}


----------------------------------
204. OurMessageChain{ mqttFixedHeader.qosLevel().value(), degree= 2, category= LOW, containerMethod= encodePublishMessage(), containerClass= MqttEncoder}
-----

public class MqttEncoder{
...
	private static ByteBuf encodePublishMessage(ByteBufAllocator byteBufAllocator, MqttPublishMessage message){
	...
		... mqttFixedHeader.qosLevelValue();
	...
	}
...
}

public class MqttFixedHeader{
...
	public int qosLevelValue(){
	...
		... qosLevel().value();
	...
	}
...
}


----------------------------------
205. OurMessageChain{ mqttFixedHeader.qosLevel().value(), degree= 2, category= LOW, containerMethod= encodePublishMessage(), containerClass= MqttEncoder}
-----

public class MqttEncoder{
...
	private static ByteBuf encodePublishMessage(ByteBufAllocator byteBufAllocator, MqttPublishMessage message){
	...
		... mqttFixedHeader.qosLevelValue();
	...
	}
...
}

public class MqttFixedHeader{
...
	public int qosLevelValue(){
	...
		... qosLevel().value();
	...
	}
...
}


----------------------------------
206. OurMessageChain{ req.command().equals(SmtpCommand.RSET), degree= 2, category= LOW, containerMethod= encode(), containerClass= SmtpRequestEncoder}
-----

public class SmtpRequestEncoder{
...
	protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception{
	...
		... req.commandEquals();
	...
	}
...
}

public class SmtpRequest{
...
	public boolean commandEquals(){
	...
		... command().equals();
	...
	}
...
}


----------------------------------
207. OurMessageChain{ req.command().encode(buffer), degree= 2, category= LOW, containerMethod= encode(), containerClass= SmtpRequestEncoder}
-----

public class SmtpRequestEncoder{
...
	protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception{
	...
		... req.commandEncode();
	...
	}
...
}

public class SmtpRequest{
...
	public void commandEncode(){
	...
		... command().encode();
	...
	}
...
}


----------------------------------
208. OurMessageChain{ req.command().isContentExpected(), degree= 2, category= LOW, containerMethod= encode(), containerClass= SmtpRequestEncoder}
-----

public class SmtpRequestEncoder{
...
	protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception{
	...
		... req.commandIsContentExpected();
	...
	}
...
}

public class SmtpRequest{
...
	public boolean commandIsContentExpected(){
	...
		... command().isContentExpected();
	...
	}
...
}


----------------------------------
209. OurMessageChain{ elementStart.attributes().add(attribute), degree= 2, category= LOW, containerMethod= decode(), containerClass= XmlDecoder}
-----

public class XmlDecoder{
...
	protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception{
	...
		... elementStart.attributesAdd();
	...
	}
...
}

public class XmlElementStart{
...
	public void attributesAdd(){
	...
		... attributes().add();
	...
	}
...
}


----------------------------------
210. OurMessageChain{ timer.pendingTimeouts.decrementAndGet(), degree= 2, category= LOW, containerMethod= remove(), containerClass= HashedWheelTimer}
-----

public class HashedWheelTimer{
...
	void remove(){
	...
		... timer.pendingTimeoutsDecrementAndGet();
	...
	}
...
}

public class HashedWheelTimer{
...
	public void pendingTimeoutsDecrementAndGet(){
	...
		... pendingTimeouts.decrementAndGet();
	...
	}
...
}


----------------------------------
211. OurMessageChain{ f.newInstance(name).debug("Using java.util.logging as the default logging framework"), degree= 2, category= LOW, containerMethod= newDefaultFactory(), containerClass= InternalLoggerFactory}
-----

public class InternalLoggerFactory{
...
	private static InternalLoggerFactory newDefaultFactory(String name){
	...
		... f.newInstanceDebug();
	...
	}
...
}

public class InternalLoggerFactory{
...
	public void newInstanceDebug(){
	...
		... newInstance(name).debug();
	...
	}
...
}


----------------------------------
212. OurMessageChain{ f.newInstance(name).debug("Using Log4J2 as the default logging framework"), degree= 2, category= LOW, containerMethod= newDefaultFactory(), containerClass= InternalLoggerFactory}
-----

public class InternalLoggerFactory{
...
	private static InternalLoggerFactory newDefaultFactory(String name){
	...
		... f.newInstanceDebug();
	...
	}
...
}

public class InternalLoggerFactory{
...
	public void newInstanceDebug(){
	...
		... newInstance(name).debug();
	...
	}
...
}


----------------------------------
213. OurMessageChain{ f.newInstance(name).debug("Using Log4J as the default logging framework"), degree= 2, category= LOW, containerMethod= newDefaultFactory(), containerClass= InternalLoggerFactory}
-----

public class InternalLoggerFactory{
...
	private static InternalLoggerFactory newDefaultFactory(String name){
	...
		... f.newInstanceDebug();
	...
	}
...
}

public class InternalLoggerFactory{
...
	public void newInstanceDebug(){
	...
		... newInstance(name).debug();
	...
	}
...
}


----------------------------------
214. OurMessageChain{ f.newInstance(name).debug("Using SLF4J as the default logging framework"), degree= 2, category= LOW, containerMethod= newDefaultFactory(), containerClass= InternalLoggerFactory}
-----

public class InternalLoggerFactory{
...
	private static InternalLoggerFactory newDefaultFactory(String name){
	...
		... f.newInstanceDebug();
	...
	}
...
}

public class InternalLoggerFactory{
...
	public void newInstanceDebug(){
	...
		... newInstance(name).debug();
	...
	}
...
}


----------------------------------
215. OurMessageChain{ b.connect(HOST, PORT).sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= DiscardClient}
-----

public class DiscardClient{
...
	public static void main(String[] args) throws Exception{
	...
		... b.connectSync();
	...
	}
...
}

public class Bootstrap{
...
	public ChannelFuture connectSync(){
	...
		... connect(HOST, PORT).sync();
	...
	}
...
}


----------------------------------
216. OurMessageChain{ b.connect(HOST, PORT).sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= EchoClient}
-----

public class EchoClient{
...
	public static void main(String[] args) throws Exception{
	...
		... b.connectSync();
	...
	}
...
}

public class Bootstrap{
...
	public ChannelFuture connectSync(){
	...
		... connect(HOST, PORT).sync();
	...
	}
...
}


----------------------------------
217. OurMessageChain{ b.connect(HOST, PORT).sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= FactorialClient}
-----

public class FactorialClient{
...
	public static void main(String[] args) throws Exception{
	...
		... b.connectSync();
	...
	}
...
}

public class Bootstrap{
...
	public ChannelFuture connectSync(){
	...
		... connect(HOST, PORT).sync();
	...
	}
...
}


----------------------------------
218. OurMessageChain{ ch.closeFuture().sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= HttpStaticFileServer}
-----

public class HttpStaticFileServer{
...
	public static void main(String[] args) throws Exception{
	...
		... ch.closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
219. OurMessageChain{ ch.closeFuture().sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= HttpHelloWorldServer}
-----

public class HttpHelloWorldServer{
...
	public static void main(String[] args) throws Exception{
	...
		... ch.closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
220. OurMessageChain{ ch.closeFuture().sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= HttpSnoopClient}
-----

public class HttpSnoopClient{
...
	public static void main(String[] args) throws Exception{
	...
		... ch.closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
221. OurMessageChain{ ch.closeFuture().sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= HttpSnoopServer}
-----

public class HttpSnoopServer{
...
	public static void main(String[] args) throws Exception{
	...
		... ch.closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
222. OurMessageChain{ trailer.trailingHeaders().isEmpty(), degree= 2, category= LOW, containerMethod= channelRead0(), containerClass= HttpSnoopServerHandler}
-----

public class HttpSnoopServerHandler{
...
	protected void channelRead0(ChannelHandlerContext ctx, Object msg){
	...
		... trailer.trailingHeadersIsEmpty();
	...
	}
...
}

public class LastHttpContent{
...
	public boolean trailingHeadersIsEmpty(){
	...
		... trailingHeaders().isEmpty();
	...
	}
...
}


----------------------------------
223. OurMessageChain{ trailer.trailingHeaders().getAll(name), degree= 2, category= LOW, containerMethod= channelRead0(), containerClass= HttpSnoopServerHandler}
-----

public class HttpSnoopServerHandler{
...
	protected void channelRead0(ChannelHandlerContext ctx, Object msg){
	...
		... trailer.trailingHeadersAll();
	...
	}
...
}

public class LastHttpContent{
...
	public List<String> trailingHeadersAll(){
	...
		... trailingHeaders().getAll();
	...
	}
...
}


----------------------------------
224. OurMessageChain{ trailer.trailingHeaders().names(), degree= 2, category= LOW, containerMethod= channelRead0(), containerClass= HttpSnoopServerHandler}
-----

public class HttpSnoopServerHandler{
...
	protected void channelRead0(ChannelHandlerContext ctx, Object msg){
	...
		... trailer.trailingHeadersNames();
	...
	}
...
}

public class LastHttpContent{
...
	public Set<String> trailingHeadersNames(){
	...
		... trailingHeaders().names();
	...
	}
...
}


----------------------------------
225. OurMessageChain{ channel.closeFuture().sync(), degree= 2, category= LOW, containerMethod= formget(), containerClass= HttpUploadClient}
-----

public class HttpUploadClient{
...
	private static List<Entry<String, String>> formget(Bootstrap bootstrap, String host, int port, String get, URI uriSimple) throws Exception{
	...
		... channel.closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
226. OurMessageChain{ future.sync().channel(), degree= 2, category= LOW, containerMethod= formpost(), containerClass= HttpUploadClient}
-----

public class HttpUploadClient{
...
	private static List<InterfaceHttpData> formpost(Bootstrap bootstrap, String host, int port, URI uriSimple, File file, HttpDataFactory factory, List<Entry<String, String>> headers) throws Exception{
	...
		... future.syncChannel();
	...
	}
...
}

public class ChannelFuture{
...
	public Channel syncChannel(){
	...
		... sync().channel();
	...
	}
...
}


----------------------------------
227. OurMessageChain{ channel.closeFuture().sync(), degree= 2, category= LOW, containerMethod= formpost(), containerClass= HttpUploadClient}
-----

public class HttpUploadClient{
...
	private static List<InterfaceHttpData> formpost(Bootstrap bootstrap, String host, int port, URI uriSimple, File file, HttpDataFactory factory, List<Entry<String, String>> headers) throws Exception{
	...
		... channel.closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
228. OurMessageChain{ future.sync().channel(), degree= 2, category= LOW, containerMethod= formpostmultipart(), containerClass= HttpUploadClient}
-----

public class HttpUploadClient{
...
	private static void formpostmultipart(Bootstrap bootstrap, String host, int port, URI uriFile, HttpDataFactory factory, Iterable<Entry<String, String>> headers, List<InterfaceHttpData> bodylist) throws Exception{
	...
		... future.syncChannel();
	...
	}
...
}

public class ChannelFuture{
...
	public Channel syncChannel(){
	...
		... sync().channel();
	...
	}
...
}


----------------------------------
229. OurMessageChain{ channel.closeFuture().sync(), degree= 2, category= LOW, containerMethod= formpostmultipart(), containerClass= HttpUploadClient}
-----

public class HttpUploadClient{
...
	private static void formpostmultipart(Bootstrap bootstrap, String host, int port, URI uriFile, HttpDataFactory factory, Iterable<Entry<String, String>> headers, List<InterfaceHttpData> bodylist) throws Exception{
	...
		... channel.closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
230. OurMessageChain{ response.status().code(), degree= 2, category= LOW, containerMethod= channelRead0(), containerClass= HttpUploadClientHandler}
-----

public class HttpUploadClientHandler{
...
	public void channelRead0(ChannelHandlerContext ctx, HttpObject msg){
	...
		... response.statusCode();
	...
	}
...
}

public class HttpResponse{
...
	public int statusCode(){
	...
		... status().code();
	...
	}
...
}


----------------------------------
231. OurMessageChain{ ch.closeFuture().sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= HttpUploadServer}
-----

public class HttpUploadServer{
...
	public static void main(String[] args) throws Exception{
	...
		... ch.closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
232. OurMessageChain{ request.method().equals(HttpMethod.GET), degree= 2, category= LOW, containerMethod= channelRead0(), containerClass= HttpUploadServerHandler}
-----

public class HttpUploadServerHandler{
...
	public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception{
	...
		... request.methodEquals();
	...
	}
...
}

public class HttpRequest{
...
	public boolean methodEquals(){
	...
		... method().equals();
	...
	}
...
}


----------------------------------
233. OurMessageChain{ ch.closeFuture().sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= WebSocketServer}
-----

public class WebSocketServer{
...
	public static void main(String[] args) throws Exception{
	...
		... ch.closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
234. OurMessageChain{ handler.handshakeFuture().sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= WebSocketClient}
-----

public class WebSocketClient{
...
	public static void main(String[] args) throws Exception{
	...
		... handler.handshakeFutureSync();
	...
	}
...
}

public class WebSocketClientHandler{
...
	public ChannelFuture handshakeFutureSync(){
	...
		... handshakeFuture().sync();
	...
	}
...
}


----------------------------------
235. OurMessageChain{ ch.closeFuture().sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= WebSocketClient}
-----

public class WebSocketClient{
...
	public static void main(String[] args) throws Exception{
	...
		... ch.closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
236. OurMessageChain{ ch.closeFuture().sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= WebSocketServer}
-----

public class WebSocketServer{
...
	public static void main(String[] args) throws Exception{
	...
		... ch.closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
237. OurMessageChain{ channel.close().syncUninterruptibly(), degree= 2, category= LOW, containerMethod= main(), containerClass= Http2Client}
-----

public class Http2Client{
...
	public static void main(String[] args) throws Exception{
	...
		... channel.closeSyncUninterruptibly();
	...
	}
...
}

public class Channel{
...
	public void closeSyncUninterruptibly(){
	...
		... close().syncUninterruptibly();
	...
	}
...
}


----------------------------------
238. OurMessageChain{ ch.closeFuture().sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= Http2Server}
-----

public class Http2Server{
...
	public static void main(String[] args) throws Exception{
	...
		... ch.closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
239. OurMessageChain{ ch.closeFuture().sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= Http2Server}
-----

public class Http2Server{
...
	public static void main(String[] args) throws Exception{
	...
		... ch.closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
240. OurMessageChain{ ch.closeFuture().sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= Http2Server}
-----

public class Http2Server{
...
	public static void main(String[] args) throws Exception{
	...
		... ch.closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
241. OurMessageChain{ http.start().sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= Launcher}
-----

public class Launcher{
...
	public static void main(String[] args){
	...
		... http.startSync();
	...
	}
...
}

public class HttpServer{
...
	public ChannelFuture startSync(){
	...
		... start().sync();
	...
	}
...
}


----------------------------------
242. OurMessageChain{ ch.close().sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= MemcacheClient}
-----

public class MemcacheClient{
...
	public static void main(String[] args) throws Exception{
	...
		... ch.closeSync();
	...
	}
...
}

public class Channel{
...
	public void closeSync(){
	...
		... close().sync();
	...
	}
...
}


----------------------------------
243. OurMessageChain{ group.next().newPromise(), degree= 2, category= LOW, containerMethod= main(), containerClass= OcspClientExample}
-----

public class OcspClientExample{
...
	public static void main(String[] args) throws Exception{
	...
		... group.nextNewPromise();
	...
	}
...
}

public class EventLoopGroup{
...
	public void nextNewPromise(){
	...
		... next().newPromise();
	...
	}
...
}


----------------------------------
244. OurMessageChain{ ch.closeFuture().await(5000), degree= 2, category= LOW, containerMethod= main(), containerClass= QuoteOfTheMomentClient}
-----

public class QuoteOfTheMomentClient{
...
	public static void main(String[] args) throws Exception{
	...
		... ch.closeFutureAwait();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureAwait(){
	...
		... closeFuture().await();
	...
	}
...
}


----------------------------------
245. OurMessageChain{ ch.close().sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= RedisClient}
-----

public class RedisClient{
...
	public static void main(String[] args) throws Exception{
	...
		... ch.closeSync();
	...
	}
...
}

public class Channel{
...
	public void closeSync(){
	...
		... close().sync();
	...
	}
...
}


----------------------------------
246. OurMessageChain{ b.connect(new RxtxDeviceAddress(PORT)).sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= RxtxClient}
-----

public class RxtxClient{
...
	public static void main(String[] args) throws Exception{
	...
		... b.connectSync();
	...
	}
...
}

public class Bootstrap{
...
	public ChannelFuture connectSync(){
	...
		... connect(new RxtxDeviceAddress(PORT)).sync();
	...
	}
...
}


----------------------------------
247. OurMessageChain{ channel.bindAddress(localSecondaryAddress).sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= SctpMultiHomingEchoClient}
-----

public class SctpMultiHomingEchoClient{
...
	public static void main(String[] args) throws Exception{
	...
		... channel.bindAddressSync();
	...
	}
...
}

public class SctpChannel{
...
	public void bindAddressSync(){
	...
		... bindAddress(localSecondaryAddress).sync();
	...
	}
...
}


----------------------------------
248. OurMessageChain{ channel.connect(remoteAddress).sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= SctpMultiHomingEchoClient}
-----

public class SctpMultiHomingEchoClient{
...
	public static void main(String[] args) throws Exception{
	...
		... channel.connectSync();
	...
	}
...
}

public class SctpChannel{
...
	public void connectSync(){
	...
		... connect(remoteAddress).sync();
	...
	}
...
}


----------------------------------
249. OurMessageChain{ channel.bindAddress(localSecondaryAddress).sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= SctpMultiHomingEchoServer}
-----

public class SctpMultiHomingEchoServer{
...
	public static void main(String[] args) throws Exception{
	...
		... channel.bindAddressSync();
	...
	}
...
}

public class SctpServerChannel{
...
	public void bindAddressSync(){
	...
		... bindAddress(localSecondaryAddress).sync();
	...
	}
...
}


----------------------------------
250. OurMessageChain{ b.connect(HOST, PORT).sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= SctpEchoClient}
-----

public class SctpEchoClient{
...
	public static void main(String[] args) throws Exception{
	...
		... b.connectSync();
	...
	}
...
}

public class Bootstrap{
...
	public ChannelFuture connectSync(){
	...
		... connect(HOST, PORT).sync();
	...
	}
...
}


----------------------------------
251. OurMessageChain{ ch.closeFuture().sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= SecureChatClient}
-----

public class SecureChatClient{
...
	public static void main(String[] args) throws Exception{
	...
		... ch.closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
252. OurMessageChain{ b.connect(request.dstAddr(), request.dstPort()).addListener(new ChannelFutureListener() {

    @Override
    public void operationComplete(ChannelFuture future) throws Exception {
        if (future.isSuccess()) {
        // Connection established use handler provided results
        } else {
            // Close the connection if the connection attempt has failed.
            ctx.channel().writeAndFlush(new DefaultSocks5CommandResponse(Socks5CommandStatus.FAILURE, request.dstAddrType()));
            SocksServerUtils.closeOnFlush(ctx.channel());
        }
    }
}), degree= 2, category= LOW, containerMethod= channelRead0(), containerClass= SocksServerConnectHandler}
-----

public class SocksServerConnectHandler{
...
	public void channelRead0(final ChannelHandlerContext ctx, final SocksMessage message) throws Exception{
	...
		... b.connectAddListener();
	...
	}
...
}

public class Bootstrap{
...
	public ChannelFuture connectAddListener(){
	...
		... connect(request.dstAddr(), request.dstPort()).addListener();
	...
	}
...
}


----------------------------------
253. OurMessageChain{ b.connect(request.dstAddr(), request.dstPort()).addListener(new ChannelFutureListener() {

    @Override
    public void operationComplete(ChannelFuture future) throws Exception {
        if (future.isSuccess()) {
        // Connection established use handler provided results
        } else {
            // Close the connection if the connection attempt has failed.
            ctx.channel().writeAndFlush(new DefaultSocks4CommandResponse(Socks4CommandStatus.REJECTED_OR_FAILED));
            SocksServerUtils.closeOnFlush(ctx.channel());
        }
    }
}), degree= 2, category= LOW, containerMethod= channelRead0(), containerClass= SocksServerConnectHandler}
-----

public class SocksServerConnectHandler{
...
	public void channelRead0(final ChannelHandlerContext ctx, final SocksMessage message) throws Exception{
	...
		... b.connectAddListener();
	...
	}
...
}

public class Bootstrap{
...
	public ChannelFuture connectAddListener(){
	...
		... connect(request.dstAddr(), request.dstPort()).addListener();
	...
	}
...
}


----------------------------------
254. OurMessageChain{ channel.close().syncUninterruptibly(), degree= 2, category= LOW, containerMethod= main(), containerClass= SpdyClient}
-----

public class SpdyClient{
...
	public static void main(String[] args) throws Exception{
	...
		... channel.closeSyncUninterruptibly();
	...
	}
...
}

public class Channel{
...
	public void closeSyncUninterruptibly(){
	...
		... close().syncUninterruptibly();
	...
	}
...
}


----------------------------------
255. OurMessageChain{ httpMsg.headers().contains(SpdyHttpHeaders.Names.STREAM_ID), degree= 2, category= LOW, containerMethod= write(), containerClass= SpdyClientStreamIdHandler}
-----

public class SpdyClientStreamIdHandler{
...
	public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise){
	...
		... httpMsg.headersContains();
	...
	}
...
}

public class HttpMessage{
...
	public boolean headersContains(){
	...
		... headers().contains();
	...
	}
...
}


----------------------------------
256. OurMessageChain{ httpMsg.headers().setInt(Names.STREAM_ID, currentStreamId), degree= 2, category= LOW, containerMethod= write(), containerClass= SpdyClientStreamIdHandler}
-----

public class SpdyClientStreamIdHandler{
...
	public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise){
	...
		... httpMsg.headersSetInt();
	...
	}
...
}

public class HttpMessage{
...
	public HttpHeaders headersSetInt(){
	...
		... headers().setInt();
	...
	}
...
}


----------------------------------
257. OurMessageChain{ ch.closeFuture().sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= SpdyServer}
-----

public class SpdyServer{
...
	public static void main(String[] args) throws Exception{
	...
		... ch.closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
258. OurMessageChain{ ch.closeFuture().sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= TelnetClient}
-----

public class TelnetClient{
...
	public static void main(String[] args) throws Exception{
	...
		... ch.closeFutureSync();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureSync(){
	...
		... closeFuture().sync();
	...
	}
...
}


----------------------------------
259. OurMessageChain{ boot.connect(HOST, PORT).sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= ByteEchoClient}
-----

public class ByteEchoClient{
...
	public static void main(String[] args) throws Exception{
	...
		... boot.connectSync();
	...
	}
...
}

public class Bootstrap{
...
	public ChannelFuture connectSync(){
	...
		... connect(HOST, PORT).sync();
	...
	}
...
}


----------------------------------
260. OurMessageChain{ boot.connect(HOST, PORT).sync(), degree= 2, category= LOW, containerMethod= main(), containerClass= MsgEchoClient}
-----

public class MsgEchoClient{
...
	public static void main(String[] args) throws Exception{
	...
		... boot.connectSync();
	...
	}
...
}

public class Bootstrap{
...
	public ChannelFuture connectSync(){
	...
		... connect(HOST, PORT).sync();
	...
	}
...
}


----------------------------------
261. OurMessageChain{ boot.connect(peer, self).sync(), degree= 2, category= LOW, containerMethod= run(), containerClass= MsgEchoPeerBase}
-----

public class MsgEchoPeerBase{
...
	public void run() throws Exception{
	...
		... boot.connectSync();
	...
	}
...
}

public class Bootstrap{
...
	public ChannelFuture connectSync(){
	...
		... connect(peer, self).sync();
	...
	}
...
}


----------------------------------
262. OurMessageChain{ bootstrap.connect(peerAddress, myAddress).sync(), degree= 2, category= LOW, containerMethod= run(), containerClass= ByteEchoPeerBase}
-----

public class ByteEchoPeerBase{
...
	public void run() throws Exception{
	...
		... bootstrap.connectSync();
	...
	}
...
}

public class Bootstrap{
...
	public ChannelFuture connectSync(){
	...
		... connect(peerAddress, myAddress).sync();
	...
	}
...
}


----------------------------------
263. OurMessageChain{ bs.connect().addListener(new ChannelFutureListener() {

    @Override
    public void operationComplete(ChannelFuture future) throws Exception {
        if (future.cause() != null) {
            handler.startTime = -1;
            handler.println("Failed to connect: " + future.cause());
        }
    }
}), degree= 2, category= LOW, containerMethod= connect(), containerClass= UptimeClient}
-----

public class UptimeClient{
...
	static void connect(){
	...
		... bs.connectAddListener();
	...
	}
...
}

public class Bootstrap{
...
	public ChannelFuture connectAddListener(){
	...
		... connect().addListener();
	...
	}
...
}


----------------------------------
264. OurMessageChain{ ch.pipeline().get(WorldClockClientHandler.class), degree= 2, category= LOW, containerMethod= main(), containerClass= WorldClockClient}
-----

public class WorldClockClient{
...
	public static void main(String[] args) throws Exception{
	...
		... ch.pipeline();
	...
	}
...
}

public class Channel{
...
	public ChannelHandler pipeline(){
	...
		... pipeline().get();
	...
	}
...
}


----------------------------------
265. OurMessageChain{ ctx.channel().isWritable(), degree= 2, category= LOW, containerMethod= channelWritabilityChanged(), containerClass= FlushConsolidationHandler}
-----

public class FlushConsolidationHandler{
...
	public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception{
	...
		... ctx.channelIsWritable();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelIsWritable(){
	...
		... channel().isWritable();
	...
	}
...
}


----------------------------------
266. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= closeOutbound(), containerClass= SslHandler}
-----

public class SslHandler{
...
	public ChannelFuture closeOutbound(final ChannelPromise promise){
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
267. OurMessageChain{ ctx.executor().execute(new Runnable() {

    @Override
    public void run() {
        closeOutbound0(promise);
    }
}), degree= 2, category= LOW, containerMethod= closeOutbound(), containerClass= SslHandler}
-----

public class SslHandler{
...
	public ChannelFuture closeOutbound(final ChannelPromise promise){
	...
		... ctx.executorExecute();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void executorExecute(){
	...
		... executor().execute();
	...
	}
...
}


----------------------------------
268. OurMessageChain{ ctx.channel().isActive(), degree= 2, category= LOW, containerMethod= exceptionCaught(), containerClass= SslHandler}
-----

public class SslHandler{
...
	public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception{
	...
		... ctx.channelIsActive();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelIsActive(){
	...
		... channel().isActive();
	...
	}
...
}


----------------------------------
269. OurMessageChain{ ctx.channel().isActive(), degree= 2, category= LOW, containerMethod= closeOutboundAndChannel(), containerClass= SslHandler}
-----

public class SslHandler{
...
	private void closeOutboundAndChannel(final ChannelHandlerContext ctx, final ChannelPromise promise, boolean disconnect) throws Exception{
	...
		... ctx.channelIsActive();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelIsActive(){
	...
		... channel().isActive();
	...
	}
...
}


----------------------------------
270. OurMessageChain{ ctx.channel().isActive(), degree= 2, category= LOW, containerMethod= handlerAdded(), containerClass= SslHandler}
-----

public class SslHandler{
...
	public void handlerAdded(final ChannelHandlerContext ctx) throws Exception{
	...
		... ctx.channelIsActive();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelIsActive(){
	...
		... channel().isActive();
	...
	}
...
}


----------------------------------
271. OurMessageChain{ ctx.executor().schedule(new Runnable() {

    @Override
    public void run() {
        if (promise.isDone()) {
            return;
        }
        try {
            if (handshakePromise.tryFailure(HANDSHAKE_TIMED_OUT)) {
                SslUtils.handleHandshakeFailure(ctx, HANDSHAKE_TIMED_OUT, true);
            }
        } finally {
            releaseAndFailAll(HANDSHAKE_TIMED_OUT);
        }
    }
}, handshakeTimeoutMillis, TimeUnit.MILLISECONDS), degree= 2, category= LOW, containerMethod= applyHandshakeTimeout(), containerClass= SslHandler}
-----

public class SslHandler{
...
	private void applyHandshakeTimeout(Promise<Channel> p){
	...
		... ctx.executorSchedule();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void executorSchedule(){
	...
		... executor().schedule();
	...
	}
...
}


----------------------------------
272. OurMessageChain{ ctx.executor().schedule(new Runnable() {

    @Override
    public void run() {
        if (!sslClosePromise.isDone()) {
            logger.debug("{} did not receive close_notify in {}ms; force-closing the connection.", ctx.channel(), closeNotifyReadTimeout);
            // Do the close now...
            addCloseListener(ctx.close(ctx.newPromise()), promise);
        }
    }
}, closeNotifyReadTimeout, TimeUnit.MILLISECONDS), degree= 2, category= LOW, containerMethod= operationComplete(), containerClass= SslHandler}
-----

public class SslHandler{
...
	public void operationComplete(ChannelFuture f) throws Exception{
	...
		... ctx.executorSchedule();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void executorSchedule(){
	...
		... executor().schedule();
	...
	}
...
}


----------------------------------
273. OurMessageChain{ ctx.channel().isActive(), degree= 2, category= LOW, containerMethod= safeClose(), containerClass= SslHandler}
-----

public class SslHandler{
...
	private void safeClose(final ChannelHandlerContext ctx, final ChannelFuture flushFuture, final ChannelPromise promise){
	...
		... ctx.channelIsActive();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelIsActive(){
	...
		... channel().isActive();
	...
	}
...
}


----------------------------------
274. OurMessageChain{ ctx.executor().schedule(new Runnable() {

    @Override
    public void run() {
        // May be done in the meantime as cancel(...) is only best effort.
        if (!flushFuture.isDone()) {
            logger.warn("{} Last write attempt timed out; force-closing the connection.", ctx.channel());
            addCloseListener(ctx.close(ctx.newPromise()), promise);
        }
    }
}, closeNotifyTimeout, TimeUnit.MILLISECONDS), degree= 2, category= LOW, containerMethod= safeClose(), containerClass= SslHandler}
-----

public class SslHandler{
...
	private void safeClose(final ChannelHandlerContext ctx, final ChannelFuture flushFuture, final ChannelPromise promise){
	...
		... ctx.executorSchedule();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void executorSchedule(){
	...
		... executor().schedule();
	...
	}
...
}


----------------------------------
275. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= resumeTransfer(), containerClass= ChunkedWriteHandler}
-----

public class ChunkedWriteHandler{
...
	public void resumeTransfer(){
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
276. OurMessageChain{ ctx.executor().execute(new Runnable() {

    @Override
    public void run() {
        resumeTransfer0(ctx);
    }
}), degree= 2, category= LOW, containerMethod= resumeTransfer(), containerClass= ChunkedWriteHandler}
-----

public class ChunkedWriteHandler{
...
	public void resumeTransfer(){
	...
		... ctx.executorExecute();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void executorExecute(){
	...
		... executor().execute();
	...
	}
...
}


----------------------------------
277. OurMessageChain{ ctx.channel().isWritable(), degree= 2, category= LOW, containerMethod= channelWritabilityChanged(), containerClass= ChunkedWriteHandler}
-----

public class ChunkedWriteHandler{
...
	public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception{
	...
		... ctx.channelIsWritable();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelIsWritable(){
	...
		... channel().isWritable();
	...
	}
...
}


----------------------------------
278. OurMessageChain{ ctx.channel().isActive(), degree= 2, category= LOW, containerMethod= handlerAdded(), containerClass= IdleStateHandler}
-----

public class IdleStateHandler{
...
	public void handlerAdded(ChannelHandlerContext ctx) throws Exception{
	...
		... ctx.channelIsActive();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelIsActive(){
	...
		... channel().isActive();
	...
	}
...
}


----------------------------------
279. OurMessageChain{ ctx.channel().isRegistered(), degree= 2, category= LOW, containerMethod= handlerAdded(), containerClass= IdleStateHandler}
-----

public class IdleStateHandler{
...
	public void handlerAdded(ChannelHandlerContext ctx) throws Exception{
	...
		... ctx.channelIsRegistered();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelIsRegistered(){
	...
		... channel().isRegistered();
	...
	}
...
}


----------------------------------
280. OurMessageChain{ ctx.channel().isActive(), degree= 2, category= LOW, containerMethod= channelRegistered(), containerClass= IdleStateHandler}
-----

public class IdleStateHandler{
...
	public void channelRegistered(ChannelHandlerContext ctx) throws Exception{
	...
		... ctx.channelIsActive();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelIsActive(){
	...
		... channel().isActive();
	...
	}
...
}


----------------------------------
281. OurMessageChain{ ctx.executor().schedule(task, delay, unit), degree= 2, category= LOW, containerMethod= schedule(), containerClass= IdleStateHandler}
-----

public class IdleStateHandler{
...
	ScheduledFuture<?> schedule(ChannelHandlerContext ctx, Runnable task, long delay, TimeUnit unit){
	...
		... ctx.executorSchedule();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void executorSchedule(){
	...
		... executor().schedule();
	...
	}
...
}


----------------------------------
282. OurMessageChain{ ctx.channel().isOpen(), degree= 2, category= LOW, containerMethod= run(), containerClass= IdleStateHandler}
-----

public class IdleStateHandler{
...
	public void run(){
	...
		... ctx.channelIsOpen();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelIsOpen(){
	...
		... channel().isOpen();
	...
	}
...
}


----------------------------------
283. OurMessageChain{ ctx.executor().schedule(task, timeoutNanos, TimeUnit.NANOSECONDS), degree= 2, category= LOW, containerMethod= scheduleTimeout(), containerClass= WriteTimeoutHandler}
-----

public class WriteTimeoutHandler{
...
	private void scheduleTimeout(final ChannelHandlerContext ctx, final ChannelPromise promise){
	...
		... ctx.executorSchedule();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void executorSchedule(){
	...
		... executor().schedule();
	...
	}
...
}


----------------------------------
284. OurMessageChain{ channel.config().setAutoRead(true), degree= 2, category= LOW, containerMethod= releaseReadSuspended(), containerClass= AbstractTrafficShapingHandler}
-----

public class AbstractTrafficShapingHandler{
...
	void releaseReadSuspended(ChannelHandlerContext ctx){
	...
		... channel.configSetAutoRead();
	...
	}
...
}

public class Channel{
...
	public ChannelConfig configSetAutoRead(){
	...
		... config().setAutoRead();
	...
	}
...
}


----------------------------------
285. OurMessageChain{ ctx.executor().schedule(reopenTask, wait, TimeUnit.MILLISECONDS), degree= 2, category= LOW, containerMethod= channelRead(), containerClass= AbstractTrafficShapingHandler}
-----

public class AbstractTrafficShapingHandler{
...
	public void channelRead(final ChannelHandlerContext ctx, final Object msg) throws Exception{
	...
		... ctx.executorSchedule();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void executorSchedule(){
	...
		... executor().schedule();
	...
	}
...
}


----------------------------------
286. OurMessageChain{ ctx.channel().isActive(), degree= 2, category= LOW, containerMethod= handlerAdded(), containerClass= ProxyHandler}
-----

public class ProxyHandler{
...
	public final void handlerAdded(ChannelHandlerContext ctx) throws Exception{
	...
		... ctx.channelIsActive();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean channelIsActive(){
	...
		... channel().isActive();
	...
	}
...
}


----------------------------------
287. OurMessageChain{ ctx.executor().schedule(new Runnable() {

    @Override
    public void run() {
        if (!connectPromise.isDone()) {
            setConnectFailure(new ProxyConnectException(exceptionMessage("timeout")));
        }
    }
}, connectTimeoutMillis, TimeUnit.MILLISECONDS), degree= 2, category= LOW, containerMethod= sendInitialMessage(), containerClass= ProxyHandler}
-----

public class ProxyHandler{
...
	private void sendInitialMessage(final ChannelHandlerContext ctx) throws Exception{
	...
		... ctx.executorSchedule();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void executorSchedule(){
	...
		... executor().schedule();
	...
	}
...
}


----------------------------------
288. OurMessageChain{ p.context(decoder).name(), degree= 2, category= LOW, containerMethod= addCodec(), containerClass= Socks4ProxyHandler}
-----

public class Socks4ProxyHandler{
...
	protected void addCodec(ChannelHandlerContext ctx) throws Exception{
	...
		... p.contextName();
	...
	}
...
}

public class ChannelPipeline{
...
	public String contextName(){
	...
		... context(decoder).name();
	...
	}
...
}


----------------------------------
289. OurMessageChain{ p.context(decoder).name(), degree= 2, category= LOW, containerMethod= addCodec(), containerClass= Socks5ProxyHandler}
-----

public class Socks5ProxyHandler{
...
	protected void addCodec(ChannelHandlerContext ctx) throws Exception{
	...
		... p.contextName();
	...
	}
...
}

public class ChannelPipeline{
...
	public String contextName(){
	...
		... context(decoder).name();
	...
	}
...
}


----------------------------------
290. OurMessageChain{ method.toString().length(), degree= 2, category= LOW, containerMethod= oldMapMixMethods(), containerClass= HttpMethodMapBenchmark}
-----

public class HttpMethodMapBenchmark{
...
	public int oldMapMixMethods() throws Exception{
	...
		... method.toStringLength();
	...
	}
...
}

public class HttpMethod{
...
	public void toStringLength(){
	...
		... toString().length();
	...
	}
...
}


----------------------------------
291. OurMessageChain{ method.toString().length(), degree= 2, category= LOW, containerMethod= newMapMixMethods(), containerClass= HttpMethodMapBenchmark}
-----

public class HttpMethodMapBenchmark{
...
	public int newMapMixMethods() throws Exception{
	...
		... method.toStringLength();
	...
	}
...
}

public class HttpMethod{
...
	public void toStringLength(){
	...
		... toString().length();
	...
	}
...
}


----------------------------------
292. OurMessageChain{ method.toString().length(), degree= 2, category= LOW, containerMethod= oldMapUnknownMethods(), containerClass= HttpMethodMapBenchmark}
-----

public class HttpMethodMapBenchmark{
...
	public int oldMapUnknownMethods() throws Exception{
	...
		... method.toStringLength();
	...
	}
...
}

public class HttpMethod{
...
	public void toStringLength(){
	...
		... toString().length();
	...
	}
...
}


----------------------------------
293. OurMessageChain{ method.toString().length(), degree= 2, category= LOW, containerMethod= newMapUnknownMethods(), containerClass= HttpMethodMapBenchmark}
-----

public class HttpMethodMapBenchmark{
...
	public int newMapUnknownMethods() throws Exception{
	...
		... method.toStringLength();
	...
	}
...
}

public class HttpMethod{
...
	public void toStringLength(){
	...
		... toString().length();
	...
	}
...
}


----------------------------------
294. OurMessageChain{ buf.writeBytes(CRLF).resetWriterIndex(), degree= 2, category= LOW, containerMethod= byteArray2(), containerClass= WriteBytesVsShortOrMediumBenchmark}
-----

public class WriteBytesVsShortOrMediumBenchmark{
...
	public ByteBuf byteArray2(){
	...
		... buf.writeBytesResetWriterIndex();
	...
	}
...
}

public class ByteBuf{
...
	public ByteBuf writeBytesResetWriterIndex(){
	...
		... writeBytes(CRLF).resetWriterIndex();
	...
	}
...
}


----------------------------------
295. OurMessageChain{ buf.writeBytes(ZERO_CRLF).resetWriterIndex(), degree= 2, category= LOW, containerMethod= byteArray3(), containerClass= WriteBytesVsShortOrMediumBenchmark}
-----

public class WriteBytesVsShortOrMediumBenchmark{
...
	public ByteBuf byteArray3(){
	...
		... buf.writeBytesResetWriterIndex();
	...
	}
...
}

public class ByteBuf{
...
	public ByteBuf writeBytesResetWriterIndex(){
	...
		... writeBytes(ZERO_CRLF).resetWriterIndex();
	...
	}
...
}


----------------------------------
296. OurMessageChain{ buffer.slice(buffer.readerIndex(), DATA_FRAME_HEADER_LENGTH).writerIndex(0), degree= 2, category= LOW, containerMethod= slice(), containerClass= Http2FrameWriterDataBenchmark}
-----

public class Http2FrameWriterDataBenchmark{
...
	ByteBuf slice(int data, int padding, boolean endOfStream){
	...
		... buffer.sliceWriterIndex();
	...
	}
...
}

public class ByteBuf{
...
	public int sliceWriterIndex(){
	...
		... slice(buffer.readerIndex(), DATA_FRAME_HEADER_LENGTH).writerIndex();
	...
	}
...
}


----------------------------------
297. OurMessageChain{ unpooledAllocator.directBuffer(size).release(), degree= 2, category= LOW, containerMethod= allocateRelease(), containerClass= ByteBufAllocatorConcurrentBenchmark}
-----

public class ByteBufAllocatorConcurrentBenchmark{
...
	public boolean allocateRelease(){
	...
		... unpooledAllocator.directBufferRelease();
	...
	}
...
}

public class ByteBufAllocator{
...
	public void directBufferRelease(){
	...
		... directBuffer(size).release();
	...
	}
...
}


----------------------------------
298. OurMessageChain{ unsafeBuffer.setLong(0, 1).getLong(0), degree= 2, category= LOW, containerMethod= setGetLongUnsafeByteBuf(), containerClass= UnsafeByteBufBenchmark}
-----

public class UnsafeByteBufBenchmark{
...
	public long setGetLongUnsafeByteBuf(){
	...
		... unsafeBuffer.setLongLong();
	...
	}
...
}

public class ByteBuf{
...
	public long setLongLong(){
	...
		... setLong(0, 1).getLong();
	...
	}
...
}


----------------------------------
299. OurMessageChain{ chan.alloc().directBuffer(1), degree= 2, category= LOW, containerMethod= setup(), containerClass= EpollSocketChannelBenchmark}
-----

public class EpollSocketChannelBenchmark{
...
	public void setup() throws Exception{
	...
		... chan.allocDirectBuffer();
	...
	}
...
}

public class Channel{
...
	public ByteBuf allocDirectBuffer(){
	...
		... alloc().directBuffer();
	...
	}
...
}


----------------------------------
300. OurMessageChain{ chan.close().sync(), degree= 2, category= LOW, containerMethod= tearDown(), containerClass= EpollSocketChannelBenchmark}
-----

public class EpollSocketChannelBenchmark{
...
	public void tearDown() throws Exception{
	...
		... chan.closeSync();
	...
	}
...
}

public class Channel{
...
	public void closeSync(){
	...
		... close().sync();
	...
	}
...
}


----------------------------------
301. OurMessageChain{ serverChan.close().sync(), degree= 2, category= LOW, containerMethod= tearDown(), containerClass= EpollSocketChannelBenchmark}
-----

public class EpollSocketChannelBenchmark{
...
	public void tearDown() throws Exception{
	...
		... serverChan.closeSync();
	...
	}
...
}

public class Channel{
...
	public void closeSync(){
	...
		... close().sync();
	...
	}
...
}


----------------------------------
302. OurMessageChain{ clientSslHandler.handshakeFuture().isDone(), degree= 2, category= LOW, containerMethod= doHandshake(), containerClass= AbstractSslHandlerBenchmark}
-----

public class AbstractSslHandlerBenchmark{
...
	protected final void doHandshake() throws Exception{
	...
		... clientSslHandler.handshakeFutureIsDone();
	...
	}
...
}

public class SslHandler{
...
	public void handshakeFutureIsDone(){
	...
		... handshakeFuture().isDone();
	...
	}
...
}


----------------------------------
303. OurMessageChain{ serverSslHandler.handshakeFuture().isDone(), degree= 2, category= LOW, containerMethod= doHandshake(), containerClass= AbstractSslHandlerBenchmark}
-----

public class AbstractSslHandlerBenchmark{
...
	protected final void doHandshake() throws Exception{
	...
		... serverSslHandler.handshakeFutureIsDone();
	...
	}
...
}

public class SslHandler{
...
	public void handshakeFutureIsDone(){
	...
		... handshakeFuture().isDone();
	...
	}
...
}


----------------------------------
304. OurMessageChain{ connection.remote().flowController(controller), degree= 2, category= LOW, containerMethod= setupTrial(), containerClass= NoPriorityByteDistributionBenchmark}
-----

public class NoPriorityByteDistributionBenchmark{
...
	public void setupTrial() throws Exception{
	...
		... connection.remoteFlowController();
	...
	}
...
}

public class Http2Connection{
...
	public void remoteFlowController(){
	...
		... remote().flowController();
	...
	}
...
}


----------------------------------
305. OurMessageChain{ connection.local().createStream(toStreamId(i), false), degree= 2, category= LOW, containerMethod= setupTrial(), containerClass= NoPriorityByteDistributionBenchmark}
-----

public class NoPriorityByteDistributionBenchmark{
...
	public void setupTrial() throws Exception{
	...
		... connection.localCreateStream();
	...
	}
...
}

public class Http2Connection{
...
	public void localCreateStream(){
	...
		... local().createStream();
	...
	}
...
}


----------------------------------
306. OurMessageChain{ ch.pipeline().addLast(DECODER, ENCODER, responseHandler), degree= 2, category= LOW, containerMethod= initChannel(), containerClass= DnsNameResolver}
-----

public class DnsNameResolver{
...
	protected void initChannel(DatagramChannel ch) throws Exception{
	...
		... ch.pipelineAddLast();
	...
	}
...
}

public class Channel{
...
	public ChannelPipeline pipelineAddLast(){
	...
		... pipeline().addLast();
	...
	}
...
}


----------------------------------
307. OurMessageChain{ f.addressType().isInstance(e.address()), degree= 2, category= LOW, containerMethod= doResolveCached(), containerClass= DnsNameResolver}
-----

public class DnsNameResolver{
...
	private boolean doResolveCached(String hostname, DnsRecord[] additionals, Promise<InetAddress> promise, DnsCache resolveCache){
	...
		... f.addressTypeIsInstance();
	...
	}
...
}

public class InternetProtocolFamily{
...
	public void addressTypeIsInstance(){
	...
		... addressType().isInstance();
	...
	}
...
}


----------------------------------
308. OurMessageChain{ f.addressType().isInstance(e.address()), degree= 2, category= LOW, containerMethod= doResolveAllCached(), containerClass= DnsNameResolver}
-----

public class DnsNameResolver{
...
	static boolean doResolveAllCached(String hostname, DnsRecord[] additionals, Promise<List<InetAddress>> promise, DnsCache resolveCache, InternetProtocolFamily[] resolvedInternetProtocolFamilies){
	...
		... f.addressTypeIsInstance();
	...
	}
...
}

public class InternetProtocolFamily{
...
	public void addressTypeIsInstance(){
	...
		... addressType().isInstance();
	...
	}
...
}


----------------------------------
309. OurMessageChain{ parent.executor().newPromise(), degree= 2, category= LOW, containerMethod= operationComplete(), containerClass= DnsResolveContext}
-----

public class DnsResolveContext{
...
	public void operationComplete(Future<List<T>> future){
	...
		... parent.executorNewPromise();
	...
	}
...
}

public class DnsNameResolver{
...
	public void executorNewPromise(){
	...
		... executor().newPromise();
	...
	}
...
}


----------------------------------
310. OurMessageChain{ parent.executor().newPromise(), degree= 2, category= LOW, containerMethod= resolve(), containerClass= DnsResolveContext}
-----

public class DnsResolveContext{
...
	void resolve(final Promise<List<T>> promise){
	...
		... parent.executorNewPromise();
	...
	}
...
}

public class DnsNameResolver{
...
	public void executorNewPromise(){
	...
		... executor().newPromise();
	...
	}
...
}


----------------------------------
311. OurMessageChain{ parent.executor().newSucceededFuture(null), degree= 2, category= LOW, containerMethod= queryUnresolvedNameserver(), containerClass= DnsResolveContext}
-----

public class DnsResolveContext{
...
	private void queryUnresolvedNameserver(final InetSocketAddress nameServerAddr, final DnsServerAddressStream nameServerAddrStream, final int nameServerAddrStreamIndex, final DnsQuestion question, final DnsQueryLifecycleObserver queryLifecycleObserver, final Promise<List<T>> promise, final Throwable cause){
	...
		... parent.executorNewSucceededFuture();
	...
	}
...
}

public class DnsNameResolver{
...
	public void executorNewSucceededFuture(){
	...
		... executor().newSucceededFuture();
	...
	}
...
}


----------------------------------
312. OurMessageChain{ parent.executor().newPromise(), degree= 2, category= LOW, containerMethod= queryUnresolvedNameserver(), containerClass= DnsResolveContext}
-----

public class DnsResolveContext{
...
	private void queryUnresolvedNameserver(final InetSocketAddress nameServerAddr, final DnsServerAddressStream nameServerAddrStream, final int nameServerAddrStreamIndex, final DnsQuestion question, final DnsQueryLifecycleObserver queryLifecycleObserver, final Promise<List<T>> promise, final Throwable cause){
	...
		... parent.executorNewPromise();
	...
	}
...
}

public class DnsNameResolver{
...
	public void executorNewPromise(){
	...
		... executor().newPromise();
	...
	}
...
}


----------------------------------
313. OurMessageChain{ r.name().toLowerCase(Locale.US), degree= 2, category= LOW, containerMethod= onExpectedResponse(), containerClass= DnsResolveContext}
-----

public class DnsResolveContext{
...
	private void onExpectedResponse(DnsQuestion question, AddressedEnvelope<DnsResponse, InetSocketAddress> envelope, final DnsQueryLifecycleObserver queryLifecycleObserver, Promise<List<T>> promise){
	...
		... r.nameToLowerCase();
	...
	}
...
}

public class DnsRecord{
...
	public void nameToLowerCase(){
	...
		... name().toLowerCase();
	...
	}
...
}


----------------------------------
314. OurMessageChain{ r.name().toLowerCase(Locale.US), degree= 2, category= LOW, containerMethod= buildAliasMap(), containerClass= DnsResolveContext}
-----

public class DnsResolveContext{
...
	private static Map<String, String> buildAliasMap(DnsResponse response, DnsCnameCache cache, EventLoop loop){
	...
		... r.nameToLowerCase();
	...
	}
...
}

public class DnsRecord{
...
	public void nameToLowerCase(){
	...
		... name().toLowerCase();
	...
	}
...
}


----------------------------------
315. OurMessageChain{ defaultNameServerAddresses.stream().next(), degree= 2, category= LOW, containerMethod= mayOverrideNameServers(), containerClass= UnixResolverDnsServerAddressStreamProvider}
-----

public class UnixResolverDnsServerAddressStreamProvider{
...
	private boolean mayOverrideNameServers(){
	...
		... defaultNameServerAddresses.streamNext();
	...
	}
...
}

public class DnsServerAddresses{
...
	public InetSocketAddress streamNext(){
	...
		... stream().next();
	...
	}
...
}


----------------------------------
316. OurMessageChain{ channel.unsafe().closeForcibly(), degree= 2, category= LOW, containerMethod= initAndRegister(), containerClass= AbstractBootstrap}
-----

public class AbstractBootstrap{
...
	final ChannelFuture initAndRegister(){
	...
		... channel.unsafeCloseForcibly();
	...
	}
...
}

public class Channel{
...
	public void unsafeCloseForcibly(){
	...
		... unsafe().closeForcibly();
	...
	}
...
}


----------------------------------
317. OurMessageChain{ channel.unsafe().closeForcibly(), degree= 2, category= LOW, containerMethod= initAndRegister(), containerClass= AbstractBootstrap}
-----

public class AbstractBootstrap{
...
	final ChannelFuture initAndRegister(){
	...
		... channel.unsafeCloseForcibly();
	...
	}
...
}

public class Channel{
...
	public void unsafeCloseForcibly(){
	...
		... unsafe().closeForcibly();
	...
	}
...
}


----------------------------------
318. OurMessageChain{ channel.eventLoop().execute(new Runnable() {

    @Override
    public void run() {
        if (localAddress == null) {
            channel.connect(remoteAddress, connectPromise);
        } else {
            channel.connect(remoteAddress, localAddress, connectPromise);
        }
        connectPromise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
    }
}), degree= 2, category= LOW, containerMethod= doConnect(), containerClass= Bootstrap}
-----

public class Bootstrap{
...
	private static void doConnect(final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise connectPromise){
	...
		... channel.eventLoopExecute();
	...
	}
...
}

public class Channel{
...
	public void eventLoopExecute(){
	...
		... eventLoop().execute();
	...
	}
...
}


----------------------------------
319. OurMessageChain{ child.pipeline().addLast(childHandler), degree= 2, category= LOW, containerMethod= channelRead(), containerClass= ServerBootstrap}
-----

public class ServerBootstrap{
...
	public void channelRead(ChannelHandlerContext ctx, Object msg){
	...
		... child.pipelineAddLast();
	...
	}
...
}

public class Channel{
...
	public ChannelPipeline pipelineAddLast(){
	...
		... pipeline().addLast();
	...
	}
...
}


----------------------------------
320. OurMessageChain{ childGroup.register(child).addListener(new ChannelFutureListener() {

    @Override
    public void operationComplete(ChannelFuture future) throws Exception {
        if (!future.isSuccess()) {
            forceClose(child, future.cause());
        }
    }
}), degree= 2, category= LOW, containerMethod= channelRead(), containerClass= ServerBootstrap}
-----

public class ServerBootstrap{
...
	public void channelRead(ChannelHandlerContext ctx, Object msg){
	...
		... childGroup.registerAddListener();
	...
	}
...
}

public class EventLoopGroup{
...
	public ChannelFuture registerAddListener(){
	...
		... register(child).addListener();
	...
	}
...
}


----------------------------------
321. OurMessageChain{ pipeline.estimatorHandle().size(msg), degree= 2, category= LOW, containerMethod= write(), containerClass= AbstractChannel}
-----

public class AbstractChannel{
...
	public final void write(Object msg, ChannelPromise promise){
	...
		... pipeline.estimatorHandleSize();
	...
	}
...
}

public class DefaultChannelPipeline{
...
	public void estimatorHandleSize(){
	...
		... estimatorHandle().size();
	...
	}
...
}


----------------------------------
322. OurMessageChain{ next.pipeline.touch(ObjectUtil.checkNotNull(msg, "msg"), next), degree= 2, category= LOW, containerMethod= invokeChannelRead(), containerClass= AbstractChannelHandlerContext}
-----

public class AbstractChannelHandlerContext{
...
	static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg){
	...
		... next.pipelineTouch();
	...
	}
...
}

public class AbstractChannelHandlerContext{
...
	public void pipelineTouch(){
	...
		... pipeline.touch();
	...
	}
...
}


----------------------------------
323. OurMessageChain{ ctx.pipeline.incrementPendingOutboundBytes(task.size), degree= 2, category= LOW, containerMethod= init(), containerClass= AbstractChannelHandlerContext}
-----

public class AbstractChannelHandlerContext{
...
	protected static void init(AbstractWriteTask task, AbstractChannelHandlerContext ctx, Object msg, ChannelPromise promise){
	...
		... ctx.pipelineIncrementPendingOutboundBytes();
	...
	}
...
}

public class AbstractChannelHandlerContext{
...
	public void pipelineIncrementPendingOutboundBytes(){
	...
		... pipeline.incrementPendingOutboundBytes();
	...
	}
...
}


----------------------------------
324. OurMessageChain{ ctx.pipeline.decrementPendingOutboundBytes(size), degree= 2, category= LOW, containerMethod= decrementPendingOutboundBytes(), containerClass= AbstractChannelHandlerContext}
-----

public class AbstractChannelHandlerContext{
...
	private void decrementPendingOutboundBytes(){
	...
		... ctx.pipelineDecrementPendingOutboundBytes();
	...
	}
...
}

public class AbstractChannelHandlerContext{
...
	public void pipelineDecrementPendingOutboundBytes(){
	...
		... pipeline.decrementPendingOutboundBytes();
	...
	}
...
}


----------------------------------
325. OurMessageChain{ newCumulation.writeBytes(cumulation).writeBytes(next), degree= 2, category= LOW, containerMethod= copyAndCompose(), containerClass= AbstractCoalescingBufferQueue}
-----

public class AbstractCoalescingBufferQueue{
...
	protected final ByteBuf copyAndCompose(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf next){
	...
		... newCumulation.writeBytesWriteBytes();
	...
	}
...
}

public class ByteBuf{
...
	public ByteBuf writeBytesWriteBytes(){
	...
		... writeBytes(cumulation).writeBytes();
	...
	}
...
}


----------------------------------
326. OurMessageChain{ channel.config().getWriteBufferHighWaterMark(), degree= 2, category= LOW, containerMethod= incrementPendingOutboundBytes(), containerClass= ChannelOutboundBuffer}
-----

public class ChannelOutboundBuffer{
...
	private void incrementPendingOutboundBytes(long size, boolean invokeLater){
	...
		... channel.configWriteBufferHighWaterMark();
	...
	}
...
}

public class Channel{
...
	public int configWriteBufferHighWaterMark(){
	...
		... config().getWriteBufferHighWaterMark();
	...
	}
...
}


----------------------------------
327. OurMessageChain{ channel.config().getWriteBufferLowWaterMark(), degree= 2, category= LOW, containerMethod= decrementPendingOutboundBytes(), containerClass= ChannelOutboundBuffer}
-----

public class ChannelOutboundBuffer{
...
	private void decrementPendingOutboundBytes(long size, boolean invokeLater, boolean notifyWritability){
	...
		... channel.configWriteBufferLowWaterMark();
	...
	}
...
}

public class Channel{
...
	public int configWriteBufferLowWaterMark(){
	...
		... config().getWriteBufferLowWaterMark();
	...
	}
...
}


----------------------------------
328. OurMessageChain{ channel.eventLoop().execute(task), degree= 2, category= LOW, containerMethod= fireChannelWritabilityChanged(), containerClass= ChannelOutboundBuffer}
-----

public class ChannelOutboundBuffer{
...
	private void fireChannelWritabilityChanged(boolean invokeLater){
	...
		... channel.eventLoopExecute();
	...
	}
...
}

public class Channel{
...
	public void eventLoopExecute(){
	...
		... eventLoop().execute();
	...
	}
...
}


----------------------------------
329. OurMessageChain{ channel.eventLoop().execute(new Runnable() {

    @Override
    public void run() {
        close(cause, allowChannelOpen);
    }
}), degree= 2, category= LOW, containerMethod= close(), containerClass= ChannelOutboundBuffer}
-----

public class ChannelOutboundBuffer{
...
	void close(final Throwable cause, final boolean allowChannelOpen){
	...
		... channel.eventLoopExecute();
	...
	}
...
}

public class Channel{
...
	public void eventLoopExecute(){
	...
		... eventLoop().execute();
	...
	}
...
}


----------------------------------
330. OurMessageChain{ channel.config().getWriteBufferHighWaterMark(), degree= 2, category= LOW, containerMethod= bytesBeforeUnwritable(), containerClass= ChannelOutboundBuffer}
-----

public class ChannelOutboundBuffer{
...
	public long bytesBeforeUnwritable(){
	...
		... channel.configWriteBufferHighWaterMark();
	...
	}
...
}

public class Channel{
...
	public int configWriteBufferHighWaterMark(){
	...
		... config().getWriteBufferHighWaterMark();
	...
	}
...
}


----------------------------------
331. OurMessageChain{ channel.config().getWriteBufferLowWaterMark(), degree= 2, category= LOW, containerMethod= bytesBeforeWritable(), containerClass= ChannelOutboundBuffer}
-----

public class ChannelOutboundBuffer{
...
	public long bytesBeforeWritable(){
	...
		... channel.configWriteBufferLowWaterMark();
	...
	}
...
}

public class Channel{
...
	public int configWriteBufferLowWaterMark(){
	...
		... config().getWriteBufferLowWaterMark();
	...
	}
...
}


----------------------------------
332. OurMessageChain{ ctx.channel().attr(key), degree= 2, category= LOW, containerMethod= attr(), containerClass= CombinedChannelDuplexHandler}
-----

public class CombinedChannelDuplexHandler{
...
	public Attribute<T> attr(AttributeKey<T> key){
	...
		... ctx.channelAttr();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void channelAttr(){
	...
		... channel().attr();
	...
	}
...
}


----------------------------------
333. OurMessageChain{ ctx.channel().hasAttr(key), degree= 2, category= LOW, containerMethod= hasAttr(), containerClass= CombinedChannelDuplexHandler}
-----

public class CombinedChannelDuplexHandler{
...
	public boolean hasAttr(AttributeKey<T> key){
	...
		... ctx.channelHasAttr();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public void channelHasAttr(){
	...
		... channel().hasAttr();
	...
	}
...
}


----------------------------------
334. OurMessageChain{ channel.config().getOption(ChannelOption.SINGLE_EVENTEXECUTOR_PER_GROUP), degree= 2, category= LOW, containerMethod= childExecutor(), containerClass= DefaultChannelPipeline}
-----

public class DefaultChannelPipeline{
...
	private EventExecutor childExecutor(EventExecutorGroup group){
	...
		... channel.configOption();
	...
	}
...
}

public class Channel{
...
	public T configOption(){
	...
		... config().getOption();
	...
	}
...
}


----------------------------------
335. OurMessageChain{ ctx.name().equals(newName), degree= 2, category= LOW, containerMethod= replace(), containerClass= DefaultChannelPipeline}
-----

public class DefaultChannelPipeline{
...
	private ChannelHandler replace(final AbstractChannelHandlerContext ctx, String newName, ChannelHandler newHandler){
	...
		... ctx.nameEquals();
	...
	}
...
}

public class AbstractChannelHandlerContext{
...
	public void nameEquals(){
	...
		... name().equals();
	...
	}
...
}


----------------------------------
336. OurMessageChain{ channel.eventLoop().inEventLoop(), degree= 2, category= LOW, containerMethod= invokeHandlerAddedIfNeeded(), containerClass= DefaultChannelPipeline}
-----

public class DefaultChannelPipeline{
...
	final void invokeHandlerAddedIfNeeded(){
	...
		... channel.eventLoopInEventLoop();
	...
	}
...
}

public class Channel{
...
	public void eventLoopInEventLoop(){
	...
		... eventLoop().inEventLoop();
	...
	}
...
}


----------------------------------
337. OurMessageChain{ context.name().equals(name), degree= 2, category= LOW, containerMethod= context0(), containerClass= DefaultChannelPipeline}
-----

public class DefaultChannelPipeline{
...
	private AbstractChannelHandlerContext context0(String name){
	...
		... context.nameEquals();
	...
	}
...
}

public class AbstractChannelHandlerContext{
...
	public void nameEquals(){
	...
		... name().equals();
	...
	}
...
}


----------------------------------
338. OurMessageChain{ channel.unsafe().outboundBuffer(), degree= 2, category= LOW, containerMethod= incrementPendingOutboundBytes(), containerClass= DefaultChannelPipeline}
-----

public class DefaultChannelPipeline{
...
	protected void incrementPendingOutboundBytes(long size){
	...
		... channel.unsafeOutboundBuffer();
	...
	}
...
}

public class Channel{
...
	public void unsafeOutboundBuffer(){
	...
		... unsafe().outboundBuffer();
	...
	}
...
}


----------------------------------
339. OurMessageChain{ channel.unsafe().outboundBuffer(), degree= 2, category= LOW, containerMethod= decrementPendingOutboundBytes(), containerClass= DefaultChannelPipeline}
-----

public class DefaultChannelPipeline{
...
	protected void decrementPendingOutboundBytes(long size){
	...
		... channel.unsafeOutboundBuffer();
	...
	}
...
}

public class Channel{
...
	public void unsafeOutboundBuffer(){
	...
		... unsafe().outboundBuffer();
	...
	}
...
}


----------------------------------
340. OurMessageChain{ channel.config().isAutoRead(), degree= 2, category= LOW, containerMethod= readIfIsAutoRead(), containerClass= DefaultChannelPipeline}
-----

public class DefaultChannelPipeline{
...
	private void readIfIsAutoRead(){
	...
		... channel.configIsAutoRead();
	...
	}
...
}

public class Channel{
...
	public boolean configIsAutoRead(){
	...
		... config().isAutoRead();
	...
	}
...
}


----------------------------------
341. OurMessageChain{ c.closeFuture().removeListener(remover), degree= 2, category= LOW, containerMethod= remove(), containerClass= DefaultChannelGroup}
-----

public class DefaultChannelGroup{
...
	public boolean remove(Object o){
	...
		... c.closeFutureRemoveListener();
	...
	}
...
}

public class Channel{
...
	public ChannelFuture closeFutureRemoveListener(){
	...
		... closeFuture().removeListener();
	...
	}
...
}


----------------------------------
342. OurMessageChain{ ch.unsafe().close(ch.unsafe().voidPromise()), degree= 2, category= LOW, containerMethod= rebuildSelector0(), containerClass= NioEventLoop}
-----

public class NioEventLoop{
...
	private void rebuildSelector0(){
	...
		... ch.unsafeClose();
	...
	}
...
}

public class AbstractNioChannel{
...
	public void unsafeClose(){
	...
		... unsafe().close();
	...
	}
...
}


----------------------------------
343. OurMessageChain{ ch.unsafe().close(ch.unsafe().voidPromise()), degree= 2, category= LOW, containerMethod= closeAll(), containerClass= NioEventLoop}
-----

public class NioEventLoop{
...
	private void closeAll(){
	...
		... ch.unsafeClose();
	...
	}
...
}

public class AbstractNioChannel{
...
	public void unsafeClose(){
	...
		... unsafe().close();
	...
	}
...
}


----------------------------------
344. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= isEmpty(), containerClass= PendingWriteQueue}
-----

public class PendingWriteQueue{
...
	public boolean isEmpty(){
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
345. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= size(), containerClass= PendingWriteQueue}
-----

public class PendingWriteQueue{
...
	public int size(){
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
346. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= bytes(), containerClass= PendingWriteQueue}
-----

public class PendingWriteQueue{
...
	public long bytes(){
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
347. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= add(), containerClass= PendingWriteQueue}
-----

public class PendingWriteQueue{
...
	public void add(Object msg, ChannelPromise promise){
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
348. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= removeAndWriteAll(), containerClass= PendingWriteQueue}
-----

public class PendingWriteQueue{
...
	public ChannelFuture removeAndWriteAll(){
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
349. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= removeAndFailAll(), containerClass= PendingWriteQueue}
-----

public class PendingWriteQueue{
...
	public void removeAndFailAll(Throwable cause){
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
350. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= removeAndFail(), containerClass= PendingWriteQueue}
-----

public class PendingWriteQueue{
...
	public void removeAndFail(Throwable cause){
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
351. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= removeAndWrite(), containerClass= PendingWriteQueue}
-----

public class PendingWriteQueue{
...
	public ChannelFuture removeAndWrite(){
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
352. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= remove(), containerClass= PendingWriteQueue}
-----

public class PendingWriteQueue{
...
	public ChannelPromise remove(){
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
353. OurMessageChain{ ctx.executor().inEventLoop(), degree= 2, category= LOW, containerMethod= current(), containerClass= PendingWriteQueue}
-----

public class PendingWriteQueue{
...
	public Object current(){
	...
		... ctx.executorInEventLoop();
	...
	}
...
}

public class ChannelHandlerContext{
...
	public boolean executorInEventLoop(){
	...
		... executor().inEventLoop();
	...
	}
...
}


----------------------------------
354. OurMessageChain{ channel.close().awaitUninterruptibly(), degree= 2, category= LOW, containerMethod= close(), containerClass= SimpleChannelPool}
-----

public class SimpleChannelPool{
...
	public void close(){
	...
		... channel.closeAwaitUninterruptibly();
	...
	}
...
}

public class Channel{
...
	public void closeAwaitUninterruptibly(){
	...
		... close().awaitUninterruptibly();
	...
	}
...
}


----------------------------------
355. OurMessageChain{ ch.unsafe().close(ch.unsafe().voidPromise()), degree= 2, category= LOW, containerMethod= run(), containerClass= ThreadPerChannelEventLoop}
-----

public class ThreadPerChannelEventLoop{
...
	protected void run(){
	...
		... ch.unsafeClose();
	...
	}
...
}

public class Channel{
...
	public void unsafeClose(){
	...
		... unsafe().close();
	...
	}
...
}


----------------------------------
356. OurMessageChain{ channel.pipeline().fireExceptionCaught(cause), degree= 2, category= LOW, containerMethod= fireException0(), containerClass= VoidChannelPromise}
-----

public class VoidChannelPromise{
...
	private void fireException0(Throwable cause){
	...
		... channel.pipelineFireExceptionCaught();
	...
	}
...
}

public class Channel{
...
	public ChannelPipeline pipelineFireExceptionCaught(){
	...
		... pipeline().fireExceptionCaught();
	...
	}
...
}


----------------------------------
357. OurMessageChain{ alloc.directBuffer(dataLen).writeBytes(data), degree= 2, category= LOW, containerMethod= doWriteMessage(), containerClass= NioSctpChannel}
-----

public class NioSctpChannel{
...
	protected boolean doWriteMessage(Object msg, ChannelOutboundBuffer in) throws Exception{
	...
		... alloc.directBufferWriteBytes();
	...
	}
...
}

public class ByteBufAllocator{
...
	public ByteBuf directBufferWriteBytes(){
	...
		... directBuffer(dataLen).writeBytes();
	...
	}
...
}


----------------------------------
358. OurMessageChain{ ch.getAllLocalAddresses().iterator(), degree= 2, category= LOW, containerMethod= localAddress0(), containerClass= OioSctpChannel}
-----

public class OioSctpChannel{
...
	protected SocketAddress localAddress0(){
	...
		... ch.allLocalAddressesIterator();
	...
	}
...
}

public class SctpChannel{
...
	public void allLocalAddressesIterator(){
	...
		... getAllLocalAddresses().iterator();
	...
	}
...
}


----------------------------------
359. OurMessageChain{ ch.getRemoteAddresses().iterator(), degree= 2, category= LOW, containerMethod= remoteAddress0(), containerClass= OioSctpChannel}
-----

public class OioSctpChannel{
...
	protected SocketAddress remoteAddress0(){
	...
		... ch.remoteAddressesIterator();
	...
	}
...
}

public class SctpChannel{
...
	public void remoteAddressesIterator(){
	...
		... getRemoteAddresses().iterator();
	...
	}
...
}


----------------------------------
360. OurMessageChain{ sch.getAllLocalAddresses().iterator(), degree= 2, category= LOW, containerMethod= localAddress0(), containerClass= OioSctpServerChannel}
-----

public class OioSctpServerChannel{
...
	protected SocketAddress localAddress0(){
	...
		... sch.allLocalAddressesIterator();
	...
	}
...
}

public class SctpServerChannel{
...
	public void allLocalAddressesIterator(){
	...
		... getAllLocalAddresses().iterator();
	...
	}
...
}

